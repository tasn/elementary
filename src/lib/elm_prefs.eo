class Elm.Prefs (Elm.Widget, Efl.File)
{
   eo_prefix: elm_obj_prefs;
   methods {
      @property data {
         set {
            /*@
            Set user data for a given prefs widget

            @return $true, on success, $false otherwise

            Once a prefs widget is created, after elm_prefs_file_set() is
            issued on it, all of its UI elements will get default values, when
            declared on that file. To fetch an user's own, personal set of
            those values, one gets to pair a <b>prefs data</b> handle to the
            prefs widget. This is what this call is intended for.

            Prefs data values from @a prefs_data with keys matching the ones
            present on the file passed on elm_prefs_file_set() to @a obj will
            have their values applied to the respective UI elements of the
            widget.

            When @a obj dies, the values of the elements declared on its @b
            .epb file (the one set on elm_prefs_file_set()) marked as permanent
            <b>will be written back</b> to @a prefs_data, if it is writable.
            One is also able to make this writing event to take place
            automatically after each UI element modification by using
            elm_prefs_autosave_set().

            @note @a obj will keep a reference of its own for @a prefs_data,
            but you should still unreference it by yourself, after the widget
            is gone.

            @see elm_prefs_data_get()

            @since 1.8 */
            return: bool;
         }
         get {
            /*@
            Get user data for a given prefs widget

            @return A pointer to the user data of a given prefs widget on success.
            $NULL otherwise.

            @see elm_prefs_data_set() for more details

            @since 1.8 */
         }
         values {
            data: Elm_Prefs_Data * @nullable; /*@ A valid prefs_data handle */
         }
      }
      @property autosave {
         set {
            /*@
            Set whether a given prefs widget should save its values back (on
            the user data file, if set) automatically on every UI element
            changes.

            If @a autosave is $true, every call to
            elm_prefs_item_value_set(), every
            Elm_Prefs_Data_Event_Type.ELM_PREFS_DATA_EVENT_ITEM_CHANGED event
            coming for its prefs data and every UI element direct value
            changing will implicitly make the prefs values to be flushed back
            to it prefs data. If a prefs data handle with no writing
            permissions or no prefs data is set on @a prefs, naturally nothing
            will happen.

            @see elm_prefs_autosave_get()

            @since 1.8 */
         }
         get {
            /*@
            Get whether a given prefs widget is saving its values back
            automatically on changes.

            @return $true if @a prefs is saving automatically,
            $false otherwise.

            @see elm_prefs_autosave_set(), for more details

            @since 1.8 */
         }
         values {
            autosave: bool; /*@ $true to save automatically, $false
            otherwise. */
         }
      }
      reset {
         /*@
         Reset the values of a given prefs widget to a previous state.

         As can be seen on #Elm_Prefs_Reset_Mode, there are two possible
         actions to be taken by this call -- either to reset @a prefs'
         values to the defaults (declared on the $.epb file it is bound
         to) or to reset to the state they were before the last modification
         it got.

         @since 1.8 */

         params {
            @in mode: Elm_Prefs_Reset_Mode; /*@ The reset mode to apply on @a prefs */
         }
      }
      item_value_set {
         /*@
         Set the value on a given prefs widget's item.

         @return $true, on success, $false otherwise

         This will change the value of item named @a name programatically.

         @see elm_prefs_item_value_get()

         @since 1.8 */

         return: bool;
         params {
            @in name: const(char)*; /*@ The name of the item (as declared in the prefs
            collection) */
            @in value: const(Eina_Value)*; /*@ The value to set on the item. It should be typed as
            the item expects, preferably, or a conversion will
            take place */
         }
      }
      item_value_get @const {
         /*@
         Get the value of a given prefs widget's item.

         @return $true, on success, $false otherwise

         This will retrieve the value of item named @a name.

         @see elm_prefs_item_value_set()

         @since 1.8 */
         return: bool;
         params {
            @in name: const(char)*; /*@ The name of the item (as declared in the prefs
            collection) to get value from */
            @out value: Eina_Value; /*@ Where to store the value of the item. It will be
            overwritten and setup with the type the item
            is bound to */
         }
      }
      item_object_get {
         /*@
         Get the Elementary widget bound to a given prefs widget's
         item.

         @return A valid widget handle, on success, or $NULL, otherwise

         This will retrieve a handle to the real widget implementing a given
         item of @a prefs, <b>for read-only</b> actions.

         @warning You should @b never modify the state of the returned
         widget, because it's meant to be managed by @a prefs, solely.

         @see elm_prefs_item_value_set()

         @since 1.8 */

         return: const(Evas.Object)*;
         params {
            @in name: const(char)*; /*@ The name of the item (as declared in the prefs
            collection) to get object from */
         }
      }
      item_disabled_set {
         /*@
         Set whether the widget bound to a given prefs widget's item is
         disabled or not.

         @see elm_prefs_item_disabled_get()

         @since 1.8 */

         params {
            @in name: const(char)*; /*@ The name of the item (as declared in the prefs
            collection) to act on */
            @in disabled: bool; /*@ $true, to make it disabled, $false
            otherwise */
         }
      }
      item_disabled_get @const {
         /*@
         Get whether the widget bound to a given prefs widget's item is
         disabled or not.

         @return $true, if it is disabled, $false
         otherwise

         @see elm_prefs_item_disabled_set()

         @since 1.8 */
         return: bool;
         params {
            @in name: const(char)*; /*@ The name of the item (as declared in the prefs
            collection) to get disabled state from */
         }
      }
      item_swallow {
         /*@
         "Swallows" an object into a SWALLOW item of a prefs widget.

         @return $true, on success, $false otherwise

         @see elm_prefs_item_swallow() for more details

         @since 1.8 */

         return: bool;
         params {
            @in name: const(char)*; /*@ the name of the SWALLOW item (as declared in the prefs
            collection) */
            @in child: Evas.Object *; /*@ The object to occupy the item */
         }
      }
      item_editable_set {
         /*@
         Set whether the widget bound to a given prefs widget's item is
         editable or not.

         @note Only $TEXT or $TEXTAREA items' default widgets implement
         the 'editable' property. Custom registered widgets may as well
         implement them.

         @see elm_prefs_item_editable_get()

         @since 1.8 */

         params {
            @in name: const(char)*; /*@ The name of the item (as declared in the prefs
            collection) to act on */
            @in editable: bool; /*@ $true, to make it editable, $false
            otherwise */
         }
      }
      item_editable_get @const {
         /*@
         Get whether the widget bound to a given prefs widget's item is
         editable or not.

         @return $true, if it is editable, $false
         otherwise

         @see elm_prefs_item_editable_set() for more details

         @since 1.8 */
         return: bool;
         params {
            @in name: const(char)*; /*@ The name of the item (as declared in the prefs
            collection) to get editable state from */
         }
      }
      item_unswallow {
         /*@
         Unswallow an object from a SWALLOW item of a prefs widget.

         @return The unswallowed object, or NULL on errors

         @see elm_prefs_item_unswallow() for more details

         @since 1.8 */

         return: Evas.Object *;
         params {
            @in name: const(char)*; /*@ the name of the SWALLOW item (as declared in the prefs
            collection) */
         }
      }
      item_visible_set {
         /*@
         Set whether the widget bound to given prefs widget's item should be
         visible or not.

         Each prefs item may have a default visibility state, declared on
         the $.epb @a prefs it was loaded with. By this call one may alter
         that state, programatically.

         @see elm_prefs_item_visible_get()

         @since 1.8 */

         params {
            @in name: const(char)*; /*@ The name of the item (as declared in the prefs
            collection) to change visibility of */
            @in visible: bool; /*@ $true, to make it visible, $false
            otherwise */
         }
      }
      item_visible_get @const {
         /*@
         Get whether the widget bound to a given prefs widget's item is
         visible or not.

         @return $true, if it is visible, $false
         otherwise

         @see elm_prefs_item_visible_set() for more details

         @since 1.8 */
         return: bool;
         params {
            @in name: const(char)*; /*@ The name of the item (as declared in the prefs
            collection) to get visibility state from */
         }
      }
   }
   implements {
      class.constructor;
      Eo.Base.constructor;
      Efl.File.file.set;
      Efl.File.file.get;
      Evas.Object_Smart.del;
      Evas.Object_Smart.add;
      Elm.Widget.focus_next;
   }
   events {
      page,changed; [[s]]
      page,saved; [[s]]
      page,reset; [[s]]
      page,loaded; [[s]]
      item,changed; [[s]]
      action; [[ss]]
   }

}
