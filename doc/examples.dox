/**
 * @page Examples Examples
 *
 * Here is a list of all Elementary examples.
 *
 * @ref bg_01_example_page
 *
 * @ref bg_02_example_page
 *
 * @ref bg_03_example_page
 *
 * @ref actionslider_example_page
 *
 * @ref transit_example_01_explained
 *
 * @ref transit_example_02_explained
 *
 * @ref general_functions_example_page
 *
 * @ref calendar_example_01
 *
 * @ref calendar_example_02
 *
 * @ref calendar_example_03
 *
 * @ref calendar_example_04
 *
 * @ref calendar_example_05
 *
 * @ref calendar_example_06
 *
 * @ref spinner_example
 *
 * @ref slider_example
 *
 * @ref panes_example
 *
 * @ref clock_example
 *
 * @ref datetime_example
 *
 * @ref dayselector_example
 *
 * @ref mapbuf_example
 *
 * @ref map_example_01
 *
 * @ref map_example_02
 *
 * @ref map_example_03
 *
 * @ref diskselector_example_01
 *
 * @ref diskselector_example_02
 *
 * @ref entry_example
 *
 * @ref list_example_01
 *
 * @ref list_example_02
 *
 * @ref list_example_03
 *
 * @ref toolbar_example_01
 *
 * @ref toolbar_example_02
 *
 * @ref toolbar_example_03
 *
 * @ref segment_control_example
 *
 * @ref flipselector_example
 *
 * @ref fileselector_example
 *
 * @ref fileselector_button_example
 *
 * @ref fileselector_entry_example
 *
 * @ref index_example_01
 *
 * @ref index_example_02
 *
 * @ref gengrid_example
 *
 * @ref genlist_example_01
 *
 * @ref genlist_example_02
 *
 * @ref genlist_example_03
 *
 * @ref genlist_example_04
 *
 * @ref genlist_example_05
 *
 * @ref glview_example_01_page
 *
 * @ref thumb_example_01
 *
 * @ref progressbar_example
 *
 * @ref slideshow_example
 *
 * @ref efl_thread_1
 *
 * @ref efl_thread_2
 *
 * @ref efl_thread_3
 *
 * @ref efl_thread_4
 *
 * @ref efl_thread_5
 *
 * @ref efl_thread_6
 *
 * @ref prefs_example_01
 *
 * @ref prefs_example_02
 *
 * @ref prefs_example_03
 */

/**
 * @page bg_01_example_page elm_bg - Plain color background.
 * @dontinclude bg_example_01.c
 *
 * The full code for this example can be found at @ref bg_example_01_c,
 * in the function @c test_bg_plain. It's part of the @c elementary_test
 * suite, and thus has the code for the three examples referenced by this
 * documentation.
 *
 * This first example just sets a default background with a plain color. The
 * first part consists of creating an Elementary window. It's the common
 * piece of code that you'll see everywhere in Elementary: @skip elm_main
 * @until autodel_set
 *
 * Now we really create our background object, using the window object as
 * its parent:
 *
 * @skipline bg_add
 *
 * Then we set the size hints of the background object so that it will use
 * all space available for it, and then add it as a resize object to the
 * window, making it visible in the end:
 *
 * @skip size_hint_weight_set
 * @until resize_object_add
 *
 * See evas_object_size_hint_weight_set() and elm_win_resize_object_add()
 * for more detailed info about these functions.
 *
 * The end of the example is quite simple, just setting the minimum and
 * maximum size of the background, so the Elementary window knows that it
 * has to have at least the minimum size. The background also won't scale to
 * a size above its maximum. Then we resize the window and show it in the
 * end:
 *
 * @skip set size hints
 * @until }
 *
 * And here we finish our very simple background object usage example.
 */

/**
 * @page bg_02_example_page elm_bg - Image background.
 * @dontinclude bg_example_02.c
 *
 * The full code for this example can be found at @ref bg_example_02_c,
 * in the function @c test_bg_image. It's part of the @c elementary_test
 * suite, and thus has the code for the three examples referenced by this
 * documentation.
 *
 * This is the second example, and shows how to use the Elementary
 * background object to set an image as background of your application.
 *
 * We start this example exactly in the same way as the previous one, even
 * when creating the background object:
 *
 * @skip elm_main
 * @until bg_add
 *
 * Now it's the different part.
 *
 * Our background will have an image, that will be displayed over the
 * background color. Before loading the image, we set the load size of the
 * image. The load size is a hint about the size that we want the image
 * displayed in the screen. It's not the exact size that the image will have,
 * but usually a bit bigger. The background object can still be scaled to a
 * size bigger than the one set here. Setting the image load size to
 * something smaller than its real size will reduce the memory used to keep
 * the pixmap representation of the image, and the time to load it. Here we
 * set the load size to 20x20 pixels, but the image is loaded with a size
 * bigger than that (since it's just a hint):
 *
 * @skipline load_size_set
 *
 * And set our background image to be centered, instead of stretched or
 * scaled, so the effect of the elm_bg_load_size_set() can be easily
 * understood:
 *
 * @skipline option_set
 *
 * We need a filename to set, so we get one from the previous installed
 * images in the @c PACKAGE_DATA_DIR, and write its full path to a buffer.
 * Then we use this buffer to set the filename in the background object:
 *
 * @skip snprintf
 * @until bg_file_set
 *
 * Notice that the third argument of the elm_bg_file_set() function is @c
 * NULL, since we are setting an image to this background. This function
 * also supports setting an edje group as background, in which case the @c
 * group parameter wouldn't be @c NULL, but be the name of the group
 * instead.
 *
 * Finally, we can set the size hints, add the background as a resize
 * object, and resize the window, exactly the same thing we do in the @ref
 * bg_01_example_page example:
 *
 * @skip size_hint
 * @until }
 *
 * And this is the end of this example.
 *
 * This example will look like this:
 *
 * @image html screenshots/bg_01.png
 * @image latex screenshots/bg_01.eps width=\textwidth
 */

/**
 * @page bg_03_example_page elm_bg - Background properties.
 * @dontinclude bg_example_03.c
 *
 * The full code for this example can be found at @ref bg_example_03_c, in the
 * function @c test_bg_options, with the callbacks @c _cb_overlay_changed, @c
 * _cb_color_changed and @c _cb_radio_changed defined in the beginning of the
 * file. It's part of the @c elementary_test suite, and thus has the code for
 * the three examples referenced by this documentation.
 *
 * This example will show the properties available for the background object,
 * and will use of some more widgets to set them.
 *
 * In order to do this, we will set some callbacks for these widgets. The
 * first is for the radio buttons that will be used to choose the option
 * passed as argument to elm_bg_option_set():
 *
 * @skip _cb_radio_changed
 * @until }
 *
 * The next callback will be used when setting the overlay (using
 * elm_object_content_set()):
 *
 * @skip _cb_overlay_changed
 * @until }
 * @until }
 *
 * And the last one, used to set the color (with elm_bg_color_set()):
 *
 * @skip _cb_color_changed
 * @until }
 *
 * We will get back to what these functions do soon. If you want to know more
 * about how to set these callbacks and what these widgets are, look for:
 * @li elm_radio_add()
 * @li elm_check_add()
 * @li elm_spinner_add()
 *
 * Now going to the main function, @c test_bg_options, we have the common
 * code with the other examples:
 *
 * @skip bg-options
 * @until autodel_set
 *
 * We add a plain background to this window, so it will have the default
 * background color behind everything:
 *
 * @skip bg = elm_bg_add
 * @until evas_object_show(bg)
 *
 * Then we add a vertical box (elm_box_add()) that will hold the background
 * object that we are going to play with, as well as a horizontal box that
 * will hold widgets:
 *
 * @skip elm_box_add
 * @until evas_object_show
 *
 * Now we add the background object that is going to be of use for our
 * example. It is an image background, as used in @ref bg_02_example_page ,
 * so the code should be familiar:
 *
 * @skip elm_bg_add
 * @until evas_object_show
 *
 * Notice the call to elm_box_pack_end(): it will pack the background object
 * in the end of the Elementary box declared above. Just refer to that
 * documentation for more info.
 *
 * Since this Elementary background is already an image background, we are
 * going to play with its other properties. We will change its option
 * (CENTER, SCALE, STRETCH, TILE), its color (RGB), and add an overlay to it.
 * For all of these properties, we are going to add widgets that will
 * configure them.
 *
 * First, lets add the horizontal box that will hold these widgets:
 * @skip hbox
 * @until align_set
 *
 * For now, just consider this @c hbox as a rectangle that will contain the
 * widgets, and will distribute them horizontally inside its content. Then we
 * add radio buttons that will allow us to choose the property to use with
 * this background:
 *
 * @skip radio_add
 * @until evas_object_show
 *
 * Again, I won't give details about the use of these widgets, just look for
 * their documentation if necessary. It's enough to know for now that we are
 * packing them in the @c hbox, setting a label for them, and the most
 * important parts: setting its value to @c ELM_BG_OPTION_CENTER and its
 * callback to @c _cb_radio_changed (the function defined in the beginning of
 * this example). We do this for the next 3 radio buttons added after this
 * one, each of them with a different value.
 *
 * Now taking a look at the code of the callback @c _cb_radio_changed again,
 * it will call elm_bg_option_set() with the value set from the checked radio
 * button, thus setting the option for this background. The background is
 * passed as argument to the @p data parameter of this callback, and is
 * referenced here as @c o_bg.
 *
 * Later we set the default value for this radio button:
 *
 * @skipline elm_radio_value_set
 *
 * Then we add a checkbox for the elm_object_content_set() function for the bg:
 *
 * @skip check_add
 * @until evas_object_show
 *
 * Now look at the code of the @c _cb_overlay_changed again. If the checkbox
 * state is checked, an overlay will be added to the background. It's done by
 * creating an Edje object, and setting it with elm_object_content_set() to the
 * background object. For information about what are and how to set Edje
 * object, look at the Edje documentation.
 *
 * Finally we add a spinner object (elm_spinner_add()) to be used to select
 * the color of our background. In its callback it's possible to see the call
 * to elm_bg_color_set(), which will change the color of this background.
 * This color is used by the background to fill areas where the image doesn't
 * cover (in this case, where we have an image background). The spinner is
 * also packed into the @c hbox :
 *
 * @skip elm_spinner_add
 * @until evas_object_show
 *
 * Then we just have to pack the @c hbox inside the @c box, set some size
 * hints, and show our window:
 *
 * @skip pack_end
 * @until }
 *
 * Now to see this code in action, open elementary_test, and go to the "Bg
 * Options" test. It should demonstrate what was implemented here.
 */

/**
 * @page actionslider_example_page Actionslider usage
 * @dontinclude actionslider_example_01.c
 *
 * For this example we are going to assume knowledge of evas smart callbacks
 * and some basic evas object functions. Elementary is not meant to be used
 * without evas, if you're not yet familiar with evas it probably is worth
 * checking that out.
 *
 * And now to the example, when using Elementary we start by including
 * Elementary.h:
 * @skipline #include
 *
 * Next we define some callbacks, they all share the same signature because
 * they are all to be used with evas_object_smart_callback_add().
 * The first one just prints the selected label(in two different ways):
 * @until }
 *
 * This next callback is a little more interesting, it makes the selected
 * label magnetic(except if it's the center label):
 * @until }
 *
 * This callback enables or disables the magnetic property of the center
 * label:
 * @until }
 *
 * And finally a callback to stop the main loop when the window is closed:
 * @until }
 *
 * To be able to create our actionsliders we need to do some setup, but this
 * isn't really relevant here, so if you want to know about that go @ref
 * Win "here".
 *
 * With all that boring stuff out of the way we can proceed to creating some
 * actionsliders.@n
 * All actionsliders are created the same way:
 * @skipline actionslider_add
 * Next we must choose where the indicator starts, and for this one we choose
 * the right, and set the right as magnetic:
 * @skipline indicator_pos_set
 * @until magnet_pos_set
 *
 * We then set the labels for the left and right, passing NULL as an argument
 * to any of the labels makes that position have no label.
 * @until Stop
 *
 * Furthermore we mark both left and right as enabled positions, if we didn't
 * do this all three positions would be enabled:
 * @until RIGHT
 *
 * Having the enabled positions we now add a smart callback to change
 * which position is magnetic, so that only the last selected position is
 * magnetic:
 * @until NULL
 *
 * And finally we set our printing callback and show the actionslider:
 * @until object_show
 * @skip pack_end
 *
 * For our next actionslider we are going to do much as we did for the
 * previous except we are going to have the center as the magnet(and not
 * change it):
 * @skipline actionslider_add
 * @skipline indicator_pos_set
 * @until object_show
 *
 * And another actionslider, in this one the indicator starts on the left.
 * It has labels only in the center and right, and both positions are
 * magnetic. Because the left doesn't have a label and is not magnetic once
 * the indicator leaves it can't return:
 * @skipline actionslider_add
 * @skipline indicator_pos_set
 * @until object_show
 * @note The greyed out area is a @ref Styles "style".
 *
 * And now an actionslider with a label in the indicator, and whose magnet
 * properties change based on what was last selected:
 * @skipline actionslider_add
 * @skipline indicator_pos_set
 * @until object_show
 * @note The greyed out area is a @ref Styles "style".
 *
 * We are almost done, this next one is just an actionslider with all
 * positions magnetized and having every possible label:
 * @skipline actionslider_add
 * @skipline indicator_pos_set
 * @until object_show
 *
 * And for our last actionslider we have one that turns the magnetic property
 * on and off:
 * @skipline actionslider_add
 * @skipline indicator_pos_set
 * @until object_show
 *
 * The example will look like this:
 *
 * @image html screenshots/actionslider_01.png
 * @image latex screenshots/actionslider_01.eps width=\textwidth
 *
 * See the full source code @ref actionslider_example_01 "here"
 */

/**
 * @page transit_example_03_c elm_transit - Combined effects and options.
 *
 * This example shows how to apply the following transition effects:
 * @li translation
 * @li color
 * @li rotation
 * @li wipe
 * @li zoom
 * @li resizing
 *
 * It allows you to apply more than one effect at once, and also allows to
 * set properties like event_enabled, auto_reverse, repeat_times and
 * tween_mode.
 *
 * @include transit_example_03.c
 * @example transit_example_03.c
 */

/**
 * @page transit_example_04_c elm_transit - Combined effects over two objects.
 *
 * This example shows how to apply the transition effects:
 * @li flip
 * @li resizable_flip
 * @li fade
 * @li blend
 * over two objects. This kind of transition effect is used to make one
 * object disappear and another one appear on its place.
 *
 * You can mix more than one effect of this type on the same objects, and the
 * transition will apply both.
 *
 * @include transit_example_04.c
 * @example transit_example_04.c
 */

/**
 * @page transit_example_01_explained elm_transit - Basic transit usage.
 * @dontinclude transit_example_01.c
 *
 * The full code for this example can be found at @ref transit_example_01_c.
 *
 * This example shows the simplest way of creating a transition and applying
 * it to an object. Similarly to every other elementary example, we create a
 * window, set its title, size, autodel property, and setup a callback to
 * exit the program when finished:
 *
 * @skip on_done
 * @until evas_object_resize
 *
 * We also add a resizable white background to use behind our animation:
 *
 * @skip bg_add
 * @until evas_object_show
 *
 * And then we add a button that we will use to demonstrate the effects of
 * our animation:
 *
 * @skip button_add
 * @until evas_object_show(win)
 *
 * Notice that we are not adding the button with elm_win_resize_object_add()
 * because we don't want the window to control the size of the button. We
 * will use the transition to change the button size, so it could conflict
 * with something else trying to control that size.
 *
 * Now, the simplest code possible to create the resize animation:
 *
 * @skip transit_add
 * @until transit_go
 *
 * As you can see, this code is very easy to understand. First, we create the
 * transition itself with elm_transit_add(). Then we add the button to this
 * transition with elm_transit_object_add(), which means that the transition
 * will operate over this button. The effect that we want now is changing the
 * object size from 100x50 to 300x150, and can be achieved by adding the
 * resize effect with elm_transit_effect_resizing_add().
 *
 * Finally, we set the transition time to 5 seconds and start the transition
 * with elm_transit_go(). If we wanted more effects applied to this
 * button, we could add them to the same transition. See the
 * @ref transit_example_03_c to watch many transitions being applied to an
 * object.
 */

/**
 * @page transit_example_02_explained elm_transit - Chained transitions.
 * @dontinclude transit_example_02.c
 *
 * The full code for this example can be found at @ref transit_example_02_c.
 *
 * This example shows how to implement a chain of transitions. This chain is
 * used to start a transition just after another transition ended. Similarly
 * to every other elementary example, we create a window, set its title,
 * size, autodel property, and setup a callback to exit the program when
 * finished:
 *
 * @skip on_done
 * @until evas_object_resize
 *
 * We also add a resizable white background to use behind our animation:
 *
 * @skip bg_add
 * @until evas_object_show
 *
 * This example will have a chain of 4 transitions, each of them applied to
 * one button. Thus we create 4 different buttons:
 *
 * @skip button_add
 * @until evas_object_show(bt4)
 *
 * Now we create a simple translation transition that will be started as soon
 * as the program loads. It will be our first transition, and the other
 * transitions will be started just after this transition ends:
 *
 * @skip transit_add
 * @until transit_go
 *
 * The code displayed until now has nothing different from what you have
 * already seen in @ref transit_example_01_explained, but now comes the new
 * part: instead of creating a second transition that will start later using
 * a timer, we create the it normally, and use
 * elm_transit_chain_transit_add() instead of elm_transit_go. Since we are
 * adding it in a chain after the first transition, it will start as soon as
 * the first transition ends:
 *
 * @skip transit_add
 * @until transit_chain_transit_add
 *
 * Finally we add the 2 other transitions to the chain, and run our program.
 * It will make one transition start after the other finish, and there is the
 * transition chain.
 */

/**
 * @page general_functions_example_page General (top-level) functions example
 * @dontinclude general_funcs_example.c
 *
 * As told in their documentation blocks, the
 * elm_app_compile_*_dir_set() family of functions have to be called
 * before elm_app_info_set():
 * @skip tell elm about
 * @until elm_app_info_set
 *
 * We are here setting the fallback paths to the compiling time target
 * paths, naturally. If you're building the example out of the
 * project's build system, we're assuming they are the canonical ones.
 *
 * After the program starts, elm_app_info_set() will actually run and
 * then you'll see an intrincasy: Elementary does the prefix lookup @b
 * twice. This is so because of the quicklaunch infrastructure in
 * Elementary (@ref Start), which will register a predefined prefix
 * for possible users of the launch schema. We're not hooking into a
 * quick launch, so this first call can't be avoided.
 *
 * If you ran this example from your "bindir" installation
 * directory, no output will emerge from these both attempts -- it
 * will find the "magic" file there registered and set the prefixes
 * silently. Otherwise, you could get something like:
 @verbatim
 WARNING: Could not determine its installed prefix for 'ELM'
       so am falling back on the compiled in default:
         usr
       implied by the following:
         bindir    = usr/lib
         libdir    = usr/lib
         datadir   = usr/share/elementary
         localedir = usr/share/locale
       Try setting the following environment variables:
         ELM_PREFIX     - points to the base prefix of install
       or the next 4 variables
         ELM_BIN_DIR    - provide a specific binary directory
         ELM_LIB_DIR    - provide a specific library directory
         ELM_DATA_DIR   - provide a specific data directory
         ELM_LOCALE_DIR - provide a specific locale directory
 @endverbatim
 * if you also didn't change those environment variables (remember
 * they are also a valid way of communicating your prefix to the
 * binary) - this is the scenario where it fallbacks to the paths set
 * for compile time.
 *
 * Then, you can check the prefixes set on the standard output:
 * @skip prefix was set to
 * @until locale directory is
 *
 * In the fragment
 * @skip by using this policy
 * @until elm_win_autodel_set
 * we demonstrate the use of Elementary policies. The policy defining
 * under which circumstances our application should quit automatically
 * is set to when its last window is closed (this one has just one
 * window, though). This will save us from having to set a callback
 * ourselves on the window, like done in @ref bg_example_01_c "this"
 * example. Note that we need to tell the window to delete itself's
 * object on a request to destroy the canvas coming, with
 * elm_win_autodel_set().
 *
 * What follows is some boilerplate code, creating a frame with a @b
 * button, our object of interest, and, below, widgets to change the
 * button's behavior and exemplify the group of functions in question.
 *
 * @dontinclude general_funcs_example.c
 * We enabled the focus highlight object for this window, so that you
 * can keep track of the current focused object better:
 * @skip elm_win_focus_highlight_enabled_set
 * @until evas_object_show
 * Use the tab key to navigate through the focus chain.
 *
 * @dontinclude general_funcs_example.c
 * While creating the button, we exemplify how to use Elementary's
 * finger size information to scale our UI:
 * @skip fprintf(stdout, "Elementary
 * @until evas_object_show
 *
 * @dontinclude general_funcs_example.c
 * The first checkbox's callback is:
 * @skip static void
 * @until }
 * When unsetting the checkbox, we disable the button, which will get a new
 * decoration (greyed out) and stop receiving events. The focus chain
 * will also ignore it.
 *
 * Following, there are 2 more buttons whose actions are focus/unfocus
 * the top button, respectively:
 * @skip focus callback
 * @until }
 * and
 * @skip unfocus callback
 * @until }
 * Note the situations in which they won't take effect:
 * - the button is not allowed to get focus or
 * - the button is disabled
 *
 * The first restriction above you'll get by a second checkbox, whose
 * callback is:
 * @skip focus allow callback
 * @until }
 * Note that the button will still get mouse events, though.
 *
 * Next, there's a slider controlling the button's scale:
 * @skip scaling callback
 * @until }
 *
 * Experiment with it, so you understand the effect better. If you
 * change its value, it will mess with the button's original size,
 * naturally.
 *
 * The full code for this example can be found
 * @ref general_functions_example_c "here".
 */

/**
 * @page theme_example_01 Theme - Using extensions
 *
 * @dontinclude theme_example_01.c
 *
 * Using extensions is extremely easy, discarding the part where you have to
 * write the theme for them.
 *
 * In the following example we'll be creating two buttons, one to load or
 * unload our extension theme and one to cycle around three possible styles,
 * one of which we created.
 *
 * After including our one and only header we'll jump to the callback for
 * the buttons. First one takes care of loading or unloading our extension
 * file, relative to the default theme set (thus the @c NULL in the
 * functions first parameter).
 * @skipline Elementary.h
 * @skip static void
 * @until }
 * @until }
 * @until }
 *
 * The second button, as we said before, will just switch around different
 * styles. In this case we have three of them. The first one is our custom
 * style, named after something very unlikely to find in the default theme.
 * The other two styles are the standard and one more, anchor, which exists
 * in the default and is similar to the default, except the button vanishes
 * when the mouse is not over it.
 * @skip static void
 * @until }
 * @until }
 *
 * So what happens if the style switches to our custom one when the
 * extension is loaded? Elementary falls back to the default for the
 * widget.
 *
 * And the main function, simply enough, will create the window, set the
 * buttons and their callbacks, and just to begin with our button styled
 * we're also loading our extension at the beginning.
 * @skip int
 * @until ELM_MAIN
 *
 * In this case we wanted to easily remove extensions, but all adding an
 * extension does is tell Elementary where else it should look for themes
 * when it can't find them in the default theme. Another way to do this
 * is to set the theme search order using elm_theme_set(), but this requires
 * that the developer is careful not to override any user configuration.
 * That can be helped by adding our theme to the end of whatever is already
 * set, like in the following snippet.
 * @code
 * char buf[4096];
 * snprintf(buf, sizeof(buf), "%s:./theme_example.edj", elme_theme_get(NULL);
 * elm_theme_set(NULL, buf);
 * @endcode
 *
 * If we were using overlays instead of extensions, the same thing applies,
 * but the custom theme must be added to the front of the search path.
 *
 * In the end, we should be looking at something like this:
 *
 * @image html screenshots/theme_example_01.png
 * @image latex screenshots/theme_example_01.eps width=\textwidth
 *
 * That's all. Boringly simple, and the full code in one piece can be found
 * @ref theme_example_01.c "here".
 *
 * And the code for our extension is @ref theme_example.edc "here".
 *
 * @example theme_example_01.c
 * @example theme_example.edc
 */

/**
 * @page theme_example_02 Theme - Using overlays
 *
 * @dontinclude theme_example_02.c
 *
 * Overlays are like extensions in that you tell Elementary that some other
 * theme contains the styles you need for your program. The difference is that
 * they will be look in first, so they can override the default style of any
 * widget.
 *
 * There's not much to say about them that hasn't been said in our previous
 * example about @ref theme_example_01 "extensions", so going quickly through
 * the code we have a function to load or unload the theme, which will be
 * called when we click any button.
 * @skipline Elementary.h
 * @skip static void
 * @until }
 *
 * And the main function, creating the window and adding some buttons to it.
 * We load our theme as an overlay and nothing else. Notice there's no style
 * set for any button there, which means they should be using the default
 * that we override.
 * @skip int
 * @until ELM_MAIN
 *
 * That's pretty much it. The full code is @ref theme_example_02.c "here" and
 * the definition of the theme is the same as before, and can be found in
 * @ref theme_example.edc "here".
 *
 * @example theme_example_02.c
 */

 /**
  * @page button_example_00 Button - Hello, Button!
  *
  * @dontinclude button_example_00.c
  *
  * Keeping the tradition, this is a simple "Hello, World" button example. We
  * will show how to create a button and associate and action to be performed
  * when you click on it.
  *
  * In the end, we'll be presented with something that looks like this:
  *
  * @image html screenshots/button_00.png
  * @image latex screenshots/button_00.eps width=\textwidth
  *
  * The full code of the example is @ref button_example_00.c "here" and we
  * will follow here with a rundown of it.
  *
  *
  * There is only one button on the interface which performs a basic action:
  * close the application. This behavior is described by on_click() function,
  * that interrupt the program invoking elm_exit().
  * @skip static void
  * @until }
  *
  *
  * On the main() function, we set the basic characteristics of the user
  * interface. First we use the Elementary library to create a window and
  * set its policies (such as close when the user click on the window close
  * icon).
  *
  * @skip elm_win_add
  * @until elm_policy_set
  *
  * In order to turn it visible on the WM (Window Manager), we also have to
  * associate it to a canvas through Evas library, and set its dimensions.
  *
  * @skip evas_object_resize
  * @until evas_object_show(win)
  *
  * Then we create a background associated to the window, define its dimensions,
  * and turn it visible on the canvas.
  * @skip  elm_bg_add
  * @until evas_object_show(bg)
  *
  *
  * Finally we use Elementary to create a button and Evas to set its
  * proprieties. Here we have not only to give the button dimensions, but also
  * its coordinates and the action to be performed on the click event.
  * @skip elm_button_add
  * @until evas_object_show(btn)
  *
  *
  * And we are done.
  *
  * @example button_example_00.c
  */

/**
  * @page button_example_01 Button - Complete example
  *
  * @dontinclude button_example_01.c
  *
  * A button is simple, you click on it and something happens. That said,
  * we'll go through an example to show in detail the button API less
  * commonly used.
  *
  * In the end, we'll be presented with something that looks like this:
  *
  * @image html screenshots/button_01.png
  * @image latex screenshots/button_01.eps width=\textwidth
  *
  * The full code of the example is @ref button_example_01.c "here" and we
  * will follow here with a rundown of it.
  *
  * @skip Elementary.h
  * @until Elementary.h
  * @skip struct
  * @until App_Data
  *
  * We have several buttons to set different times for the autorepeat timeouts
  * of the buttons that use it and a few more that we keep track of in our
  * data struct. The mid button doesn't do much, just moves around according
  * to what other buttons the user presses. Then four more buttons to move the
  * central one, and we're also keeping track of the icon set in the middle
  * button, since when this one moves, we change the icon, and when movement
  * is finished (by releasing one of the four arrow buttons), we set back the
  * normal icon.
  * @skip static void
  * @until }
  *
  * Keeping any of those four buttons pressed will trigger their autorepeat
  * callback, where we move the button doing some size hint magic. To
  * understand how that works better, refer to the @ref Box documentation.
  * Also, the first time the function is called, we change the icon in the
  * middle button, using elm_object_content_unset() first to keep the reference
  * to the previous one, so we don't need to recreate it when we are done
  * moving it.
  * @skip static void
  * @until }
  * @until size_hint_align_set
  * @until }
  *
  * One more callback for the option buttons, that just sets the timeouts for
  * the different autorepeat options.
  *
  * @skip static void
  * @until }
  * @until }
  * @until }
  *
  * And the main function, which does some setting up of the buttons in boxes
  * to make things work. Here we'll go through some snippets only.
  *
  * For the option buttons, it's just the button with its label and callback.
  * @skip elm_button_add
  * @until smart_callback_add
  *
  * For the ones that move the central button, we have no labels. There are
  * icons instead, and the autorepeat option is toggled.
  * @skip Gap: 1.0
  * @skip elm_button_add
  * @until data.cursors.up
  *
  * And just to show the mid button, which doesn't have anything special.
  * @skip data.cursors.left
  * @skip elm_button_add
  * @until data.mid
  *
  * And we are done.
  *
  * @example button_example_01.c
  */

/**
 * @page bubble_01_example_page elm_bubble - Simple use.
 * @dontinclude bubble_example_01.c
 *
 * This example shows a bubble with all fields set(label, info, content and
 * icon) and the selected corner changing when the bubble is clicked. To be
 * able use a bubble we need to do some setup and create a window, for this
 * example we are going to ignore that part of the code since it isn't
 * relevant to the bubble.
 *
 * To have the selected corner change in a clockwise motion we are going to
 * use the following callback:
 * @skip static
 * @until }
 * @until }
 *
 * Here we are creating an elm_label that is going to be used as the content
 * for our bubble:
 * @skipline elm_label
 * @until show
 * @note You could use any evas_object for this, we are using an elm_label
 * for simplicity.
 *
 * Despite it's name the bubble's icon doesn't have to be an icon, it can be
 * any evas_object. For this example we are going to make the icon a simple
 * blue rectangle:
 * @until show
 *
 * And finally we have the actual bubble creation and the setting of it's
 * label, info and content:
 * @until content
 * @skipline show
 * @note Because we didn't set a corner, the default("top_left") will be
 * used.
 *
 * Now that we have our bubble all that is left is connecting the "clicked"
 * signals to our callback:
 * @line smart_callback
 *
 * This last bubble we created was very complete, so it's pertinent to show
 * that most of that stuff is optional a bubble can be created with nothing
 * but content:
 * @until content
 * @skipline show
 *
 * Our example will look like this:
 *
 * @image html screenshots/bubble_example_01.png
 * @image latex screenshots/bubble_example_01.eps width=\textwidth
 *
 * See the full source code @ref bubble_example_01.c here.
 * @example bubble_example_01.c
 */

/**
 * @page box_example_01 Box - Basic API
 *
 * @dontinclude button_example_01.c
 *
 * As a special guest tonight, we have the @ref button_example_01 "simple
 * button example". There are plenty of boxes in it, and to make the cursor
 * buttons that moved a central one around when pressed, we had to use a
 * variety of values for their hints.
 *
 * To start, let's take a look at the handling of the central button when
 * we were moving it around. To achieve this effect without falling back to
 * a complete manual positioning of the @c Evas_Object in our canvas, we just
 * put it in a box and played with its alignment within it, as seen in the
 * following snippet of the callback for the pressed buttons.
 * @skip evas_object_size_hint_align_get
 * @until evas_object_size_hint_align_set
 *
 * Not much to it. We get the current alignment of the object and change it
 * by just a little, depending on which button was pressed, then set it
 * again, making sure we stay within the 0.0-1.0 range so the button moves
 * inside the space it has, instead of disappearing under the other objects.
 *
 * But as useful as an example as that may have been, the usual case with boxes
 * is to set everything at the moment they are created, like we did for
 * everything else in our main function.
 *
 * The entire layout of our program is made with boxes. We have one set as the
 * resize object for the window, which means it will always be resized with
 * the window. The weight hints set to @c EVAS_HINT_EXPAND will tell the
 * window that the box can grow past it's minimum size, which allows resizing
 * of it.
 * @skip elm_main
 * @skip elm_box_add
 * @until evas_object_show
 *
 * Two more boxes, set to horizontal, hold the buttons to change the autorepeat
 * configuration used by the buttons. We create each to take over all the
 * available space horizontally, but we don't want them to grow vertically,
 * so we keep that axis of the weight with 0.0. Then it gets packed in the
 * main box.
 * @skip box2
 * @until evas_object_show
 *
 * The buttons in each of those boxes have nothing special, they are just packed
 * in with their default values and the box will use their minimum size, as set
 * by Elementary itself based on the label, icon, finger size and theme.
 *
 * But the buttons used to move the central one have a special disposition.
 * The top one first, is placed right into the main box like our other smaller
 * boxes. Set to expand horizontally and not vertically, and in this case we
 * also tell it to fill that space, so it gets resized to take the entire
 * width of the window.
 * @skip Gap: 1.0
 * @skip elm_button_add
 * @until evas_object_show
 *
 * The bottom one will be the same, but for the other two we need to use a
 * second box set to take as much space as we have, so we can place our side
 * buttons in place and have the big empty space where the central button will
 * move.
 * @skip elm_box_add
 * @until evas_object_show
 *
 * Then the buttons will have their hints inverted to the other top and bottom
 * ones, to expand and fill vertically and keep their minimum size horizontally.
 * @skip elm_button_add
 * @until evas_object_show
 *
 * The central button takes every thing else. It will ask to be expanded in
 * both directions, but without filling its cell. Changing its alignment by
 * pressing the buttons will make it move around.
 * @skip elm_button_add
 * @until evas_object_show
 *
 * To end, the rightmost button is packed in the smaller box after the central
 * one, and back to the main box we have the bottom button at the end.
 */

/**
 * @page box_example_02 Box - Layout transitions
 *
 * @dontinclude box_example_02.c
 *
 * Setting a customized layout for a box is simple once you have the layout
 * function, which is just like the layout function for @c Evas_Box. The new
 * and fancier thing we can do with Elementary is animate the transition from
 * one layout to the next. We'll see now how to do that through a simple
 * example, while also taking a look at some of the API that was left
 * untouched in our @ref box_example_01 "previous example".
 *
 * @image html screenshots/box_example_02.png
 * @image latex screenshots/box_example_02.eps width=\textwidth
 *
 * @skipline Elementary.h
 *
 * Our application data consists of a list of layout functions, given by
 * @c transitions. We'll be animating through them throughout the entire run.
 * The box with the stuff to move around and the last layout that was set to
 * make things easier in the code.
 * @skip typedef
 * @until Transitions_Data
 *
 * The box starts with three buttons, clicking on any of them will take it
 * out of the box without deleting the object. There are also two more buttons
 * outside, one to add an object to the box and the other to clear it.
 * This is all to show how you can interact with the items in the box, add
 * things and even remove them, while the transitions occur.
 *
 * One of the callback we'll be using creates a new button, asks the box for
 * the list of its children and if it's not empty, we add the new object after
 * the first one, otherwise just place at the end as it will not make any
 * difference.
 * @skip static void
 * @until }
 * @until }
 *
 * The clear button is even simpler. Everything in the box will be deleted,
 * leaving it empty and ready to fill it up with more stuff.
 * @skip static void
 * @until }
 *
 * And a little function to remove buttons from the box without deleting them.
 * This one is set for the @c clicked callback of the original buttons,
 * unpacking them when clicked and placing it somewhere in the screen where
 * they will not disturb. Once we do this, the box no longer has any control
 * of it, so it will be left untouched until the program ends.
 * @skip static void
 * @until }
 *
 * If we wanted, we could just call @c evas_object_del() on the object to
 * destroy it. In this case, no unpack is really necessary, as the box would
 * be notified of a child being deleted and adjust its calculations accordingly.
 *
 * The core of the program is the following function. It takes whatever
 * function is first on our list of layouts and together with the
 * @c last_layout, it creates an ::Elm_Box_Transition to use with
 * elm_box_layout_transition(). In here, we tell it to start from whatever
 * layout we last set, end with the one that was at the top of the list and
 * when everything is finished, call us back so we can create another
 * transition. Finally, move the new layout to the end of the list so we
 * can continue running through them until the program ends.
 * @skip static void
 * @until }
 *
 * The main function doesn't have anything special. Creation of box, initial
 * buttons and some callback setting. The only part worth mentioning is the
 * initialization of our application data.
 * @skip tdata.box
 * @until evas_object_box_layout_stack
 *
 * We have a simple static variable, set the box, the first layout we are
 * using as last and create the list with the different functions to go
 * through.
 *
 * And in the end, we set the first layout and call the same function we went
 * through before to start the run of transitions.
 * @until _test_box_transition_change
 *
 * For the full code, follow @ref box_example_02.c "here".
 *
 * @example box_example_02.c
 */

/**
 * @page calendar_example_01 Calendar - Simple creation.
 * @dontinclude calendar_example_01.c
 *
 * As a first example, let's just display a calendar in our window,
 * explaining all steps required to do so.
 *
 * First you should declare objects we intend to use:
 * @skipline Evas_Object
 *
 * Then a window is created, a title is set and its set to be autodeleted.
 * More details can be found on windows examples:
 * @until elm_win_autodel
 *
 * Next a simple background is placed on our windows. More details on
 * @ref bg_01_example_page :
 * @until evas_object_show(bg)
 *
 * Now, the exciting part, let's add the calendar with elm_calendar_add(),
 * passing our window object as parent.
 * @until evas_object_show(cal);
 *
 * To conclude our example, we should show the window and run elm mainloop:
 * @until ELM_MAIN
 *
 * Our example will look like this:
 *
 * @image html screenshots/calendar_example_01.png
 * @image latex screenshots/calendar_example_01.eps width=\textwidth
 *
 * See the full source code @ref calendar_example_01.c here.
 * @example calendar_example_01.c
 */

/**
 * @page calendar_example_02 Calendar - Layout strings formatting.
 * @dontinclude calendar_example_02.c
 *
 * In this simple example, we'll explain how to format the label displaying
 * month and year, and also set weekday names.
 *
 * To format month and year label, we need to create a callback function
 * to create a string given the selected time, declared under a
 * <tt> struct tm </tt>.
 *
 * <tt> struct tm </tt>, declared on @c time.h, is a structure composed by
 * nine integers:
 * @li tm_sec   seconds [0,59]
 * @li tm_min   minutes [0,59]
 * @li tm_hour  hour [0,23]
 * @li tm_mday  day of month [1,31]
 * @li tm_mon   month of year [0,11]
 * @li tm_year  years since 1900
 * @li tm_wday  day of week [0,6] (Sunday = 0)
 * @li tm_yday  day of year [0,365]
 * @li tm_isdst daylight savings flag
 * @note glib version has 2 additional fields.
 *
 * For our function, only stuff that matters are tm_mon and tm_year.
 * But we don't need to access it directly, since there are nice functions
 * to format date and time, as @c strftime.
 * We will get abbreviated month (%b) and year (%y) (check strftime manpage
 * for more) in our example:
 * @skipline static char
 * @until }
 *
 * We need to alloc the string to be returned, and calendar widget will
 * free it when it's not needed, what is done by @c strdup.
 * So let's register our callback to calendar object:
 * @skipline elm_calendar_format_function_set
 *
 * To set weekday names, we should declare them as an array of strings:
 * @dontinclude calendar_example_02.c
 * @skipline weekdays[]
 * @until }
 *
 * And finally set them to calendar:
 * @skipline weekdays_names_set
 *
 * Our example will look like this:
 *
 * @image html screenshots/calendar_example_02.png
 * @image latex screenshots/calendar_example_02.eps width=\textwidth
 *
 * See the full source code @ref calendar_example_02.c here.
 * @example calendar_example_02.c
 */

/**
 * @page calendar_example_03 Calendar - Years restrictions.
 * @dontinclude calendar_example_03.c
 *
 * This example explains how to set max and min year to be displayed
 * by a calendar object. This means that user won't be able to
 * see or select a date before and after selected years.
 * By default, limits are 1902 and maximum value will depends
 * on platform architecture (year 2037 for 32 bits); You can
 * read more about time functions on @c ctime manpage.
 *
 * Straigh to the point, to set it is enough to call
 * elm_calendar_min_max_year_set(). First value is minimum year, second
 * is maximum. If first value is negative, it won't apply limit for min
 * year, if the second one is negative, won't apply for max year.
 * Setting both to negative value will clear limits (default state):
 * @skipline elm_calendar_min_max_year_set
 *
 * Our example will look like this:
 *
 * @image html screenshots/calendar_example_03.png
 * @image latex screenshots/calendar_example_03.eps width=\textwidth
 *
 * See the full source code @ref calendar_example_03.c here.
 * @example calendar_example_03.c
 */

/**
 * @page calendar_example_04 Calendar - Days selection.
 * @dontinclude calendar_example_04.c
 *
 * It's possible to disable date selection and to select a date
 * from your program, and that's what we'll see on this example.
 *
 * If isn't required that users could select a day on calendar,
 * only interacting going through months, disabling days selection
 * could be a good idea to avoid confusion. For that:
 * @skipline elm_calendar_select_mode_set
 *
 * Also, regarding days selection, you could be interested to set a
 * date to be highlighted on calendar from your code, maybe when
 * a specific event happens, or after calendar creation. As @c time output is
 * in seconds, we define the number of seconds contained within a day as a
 * constant:
 * @dontinclude calendar_example_04.c
 * @skipline SECS_DAY
 *
 * Now let's select two days from current day:
 * @skipline time(NULL)
 * @until elm_calendar_selected_time_set
 *
 * Our example will look like this:
 *
 * @image html screenshots/calendar_example_04.png
 * @image latex screenshots/calendar_example_04.eps width=\textwidth
 *
 * See the full source code @ref calendar_example_04.c here.
 * @example calendar_example_04.c
 */

/**
 * @page calendar_example_05 Calendar - Signal callback and getters.
 * @dontinclude calendar_example_05.c
 *
 * Most of setters explained on previous examples have associated getters.
 * That's the subject of this example. We'll add a callback to display
 * all calendar information every time user interacts with the calendar.
 *
 * Let's check our callback function:
 * @skipline static void
 * @until double interval;
 *
 * To get selected day, we need to call elm_calendar_selected_time_get(),
 * but to assure nothing wrong happened, we must check for function return.
 * It'll return @c EINA_FALSE if fail. Otherwise we can use time set to
 * our structure @p stime.
 * @skipline elm_calendar_selected_time_get
 * @until return
 *
 * Next we'll get information from calendar and place on declared vars:
 * @skipline interval
 * @until elm_calendar_weekdays_names_get
 *
 * The only tricky part is that last line gets an array of strings
 * (char arrays), one for each weekday.
 *
 * Then we can simple print that to stdin:
 * @skipline printf
 * @until }
 *
 * <tt> struct tm </tt> is declared on @c time.h. You can check @c ctime
 * manpage to read about it.
 *
 * To register this callback, that will be called every time user selects
 * a day or goes to next or previous month, just add a callback for signal
 * @b changed.
 * @skipline evas_object_smart_callback_add
 *
 * Our example will look like this:
 *
 * @image html screenshots/calendar_example_05.png
 * @image latex screenshots/calendar_example_05.eps width=\textwidth
 *
 * See the full source code @ref calendar_example_05.c here.
 * @example calendar_example_05.c
 */

/**
 * @page calendar_example_06 Calendar - Calendar marks.
 * @dontinclude calendar_example_06.c
 *
 * On this example marks management will be explained. Functions
 * elm_calendar_mark_add(), elm_calendar_mark_del() and
 * elm_calendar_marks_clear() will be covered.
 *
 * To add a mark, will be required to choose three things:
 * @li mark style
 * @li mark date, or start date if it will be repeated
 * @li mark periodicity
 *
 * Style defines the kind of mark will be displayed over marked day,
 * on calendar. Default theme supports @b holiday and @b checked.
 * If more is required, is possible to set a new theme to calendar
 * widget using elm_object_style_set(), and use
 * the signal that will be used by such marks.
 *
 * Date is a <tt> struct tm </tt>, as defined by @c time.h. More can
 * be read on @c ctime manpage.
 * If a date relative from current is required, this struct can be set
 * as:
 * @skipline time(NULL)
 * @until localtime_r
 *
 * Or if it's an absolute date, you can just declare the struct like:
 * @dontinclude calendar_example_06.c
 * @skipline sunday
 * @until christmas.tm_mon
 *
 * Periodicity is how frequently the mark will be displayed over the
 * calendar.  Can be a unique mark (that don't repeat), or it can repeat
 * daily, weekly, monthly or annually. It's enumerated by
 * @c Elm_Calendar_Mark_Repeat_Type.
 *
 * So let's add some marks to our calendar. We will add christmas holiday,
 * set Sundays as holidays, and check current day and day after that.
 * @dontinclude calendar_example_06.c
 * @skipline sunday
 * @until christmas.tm_mon
 * @skipline current_time
 * @until ELM_CALENDAR_WEEKLY
 *
 * We kept the return of first mark add, because we don't really won't it
 * to be checked, so let's remove it:
 * @skipline elm_calendar_mark_del
 *
 * After all marks are added and removed, is required to draw them:
 * @skipline elm_calendar_marks_draw
 *
 * Finally, to clear all marks, let's set a callback for our button:
 * @skipline elm_button_add
 * @until evas_object_show(bt);
 *
 * This callback will receive our calendar object, and should clear it:
 * @dontinclude calendar_example_06.c
 * @skipline static
 * @until }
 * @note Remember to draw marks after clear the calendar.
 *
 * Our example will look like this:
 *
 * @image html screenshots/calendar_example_06.png
 * @image latex screenshots/calendar_example_06.eps width=\textwidth
 *
 * See the full source code @ref calendar_example_06.c here.
 * @example calendar_example_06.c
 */

/**
 * @page spinner_example Spinner widget example
 *
 * This code places seven Elementary spinner widgets on a window, each of
 * them exemplifying a part of the widget's API.
 *
 * The first of them is the default spinner:
 * @dontinclude spinner_example.c
 * @skipline elm_spinner_add
 * @until evas_object_show
 * As you see, the defaults for a spinner are:
 * @li no wrap
 * @li min value set to 0
 * @li max value set to 100
 * @li step value set to 1
 * @li label format set to "%0.f"
 *
 * If another format is required, see the second spinner. It will put a text
 * before and after the value, and also format value to display two decimals:
 * @skipline format_set
 *
 * The third one will use a customized step, define new minimum and maximum
 * values and enable wrap, so when value reaches minimum it jumps to maximum,
 * or jumps to minimum after maximum value is reached. Format is set to display
 * a decimal:
 * @skipline elm_spinner_add
 * @until evas_object_show
 *
 * The fourth uses @c vertical style, so instead of left and right arrows,
 * top and bottom are displayed. Also the change interval is reduced, so
 * user can change value faster.
 * @skipline style
 * @skipline interval
 *
 * In the fifth the user won't be allowed to set value directly, i.e., will
 * be obligate change value only using arrows:
 * @skipline editable
 *
 * The sixth widget will receive a lot of special values, so
 * instead of reading numeric values, user will see labels for each one.
 * Also direct edition is disabled, otherwise users would see the numeric
 * value on edition mode. User will be able to select a month in this widget:
 * @skipline elm_spinner_add
 * @until evas_object_show
 *
 * Finally the last widget will exemplify how to listen to widget's signals,
 * <tt> changed </tt> and <tt> delay,changed </tt>. First we need to
 * implement callback functions that will simply print spinner's value:
 * @dontinclude spinner_example.c
 * @skip static
 * @skip }
 * @skipline static
 * @until }
 * @until }
 *
 * The first callback function should be called everytime value changes,
 * the second one only after user stops to increment or decrement. Try
 * to keep arrows pressed and check the difference.
 * @skip smart_callback
 * @skipline smart_callback
 * @skipline smart_callback
 *
 * See the full @ref spinner_example.c "example", whose window should
 * look like this picture:
 *
 * @image html screenshots/spinner_example.png
 * @image latex screenshots/spinner_example.eps width=\textwidth
 *
 * See the full @ref spinner_example.c "source code" for this example.
 *
 * @example spinner_example.c
 */

/**
 * @page slider_example Slider widget example
 *
 * This code places seven Elementary slider widgets on a window, each of
 * them exemplifying a part of the widget's API.
 *
 * The first of them is the default slider:
 * @dontinclude slider_example.c
 * @skipline elm_slider_add
 * @until evas_object_show
 *
 * As you see, the defaults for a slider are:
 * @li horizontal
 * @li no label
 * @li no values (on indicator or unit labels)
 *
 * Actually it's pretty useless this way. So let's learn how to improve it.
 *
 * If some decoration is required, a label can be set, and icon before and
 * after the bar as well. On the second slider will add a @c home icon
 * and a @c folder icon at @c end.
 * @skip elm_object_text_set
 * @until elm_object_part_content_set(sl, "end", ic)
 *
 * If the bar size need to be changed, it can be done with span set function,
 * that doesn't accounts other widget's parts size. Also the bar can starts
 * with a not default value (0.0), as we done on third slider:
 * @skipline value_set
 * @skipline span_size_set
 *
 * So far, users won't be able to see the slider value. If it's required,
 * it can be displayed in two different areas, units label or above
 * the indicator.
 *
 * Let's place a units label on our widget, and also let's set minimum and
 * maximum value (uses 0.0 and 1.0 by default):
 * @skipline unit_format_set
 * @skipline min_max_set
 *
 * If above the indicator is the place to display the value, just set it.
 * Also, is possible to invert a bar, as you can see:
 * @skipline indicator_format_set
 * @skipline inverted_set
 *
 * But if you require to use a function a bit more customized to show the value,
 * is possible to registry a callback function that will be called
 * to display unit or indicator label. Only the value will be passed to this
 * function, that should return a string.
 * In this case, a function to free this string will be required.
 *
 * Let's exemplify with indicator label on our sixth slider:
 * @dontinclude slider_example.c
 * @skip static
 * @skip }
 * @skip static
 * @skip }
 * @skip static
 * @skip }
 * @skipline static
 * @until }
 * @until }
 *
 * Setting callback functions:
 * @skipline indicator_format_function_set
 * @skipline _indicator_free
 *
 * Also, a slider can be displayed vertically:
 * @dontinclude slider_example.c
 * @skipline elm_slider_horizontal_set
 *
 * Finally the last widget will exemplify how to listen to widget's signals,
 * <tt> changed </tt> and <tt> delay,changed </tt>. First we need to
 * implement callback functions that will simply print slider's value:
 * @dontinclude slider_example.c
 * @skip static
 * @skip }
 * @skipline static
 * @until }
 * @until }
 *
 * The first callback function should be called everytime value changes,
 * the second one only after user stops to increment or decrement. Try
 * to keep arrows pressed and check the difference.
 * @skip smart_callback
 * @skipline smart_callback
 * @skipline smart_callback
 *
 * See the full @ref slider_example.c "example", whose window should
 * look like this picture:
 *
 * @image html screenshots/slider_example.png
 * @image latex screenshots/slider_example.eps width=\textwidth
 *
 * See the full @ref slider_example.c "source code" for this example.
 *
 * @example slider_example.c
 */

/**
 * @page panes_example Panes widget example
 *
 * This code places two Elementary panes widgets on a window, one of them
 * displayed vertically and the other horizontally, to exemplify
 * a part of the widget's API. Also, all the signals emitted by this
 * widget will be covered.
 *
 * Let's start adding a panes to our window:
 * @dontinclude panes_example.c
 * @skipline elm_panes_add
 * @until evas_object_show
 *
 * Now we will set a content (a simple button) to the left side of our
 * panes widget:
 * @skipline elm_button_add
 * @until content_left_set
 *
 * The content of the right side will be something a bit more elaborated, we'll
 * place another panes, displayed vertically (it's displayed horizontally
 * by default):
 * @skipline elm_panes_add
 * @until content_right_set
 *
 * When populating a panes displayed vertically, remember that left content
 * will be placed at top, and right content will place at bottom. Next
 * we will add two buttons to exemplify that:
 * @skipline elm_button_add
 * @until content_right_set
 *
 * Panes widgets emits 4 different signals, depending on users interaction
 * with the draggable bar. We'll add a callback function for each of them.
 *
 * <tt> "clicked" signal </tt>:
 *
 * Callback function that just print "Clicked" to stdin:
 * @dontinclude panes_example.c
 * @skip static void
 * @skip }
 * @skip static void
 * @skip }
 * @skip static void
 * @skip }
 * @skipline static void
 * @until }
 *
 * Also, add callback function to the panes:
 * @skipline "clicked"
 *
 * <tt> "press" signal </tt>:
 *
 * Callback function that just print "Pressed" to stdin:
 * @dontinclude panes_example.c
 * @skip static void
 * @skip }
 * @skipline static void
 * @until }
 *
 * Also, add callback function to the panes:
 * @skipline "press"
 *
 * Now, let's try to make our callback functions a bit more useful:
 *
 * <tt> "unpress" signal </tt>:
 *
 * Suppose we want to know the size proportion of left content after
 * user drags the bar. We need to listen for @c unpress signal, and
 * get this size from our panes widget. It's done on the following
 * function:
 * @dontinclude panes_example.c
 * @skip static void
 * @skip }
 * @skip static void
 * @skip }
 * @skipline static void
 * @until }
 *
 * Adding the callback function to the panes:
 * @skipline "unpress"

 * <tt> "clicked,double" signal </tt>:
 *
 * Now, a interesting feature that could be addded to panes widget.
 * Hide a content when user double click the draggable bar. It's done
 * using a variable to store size and content left size getter and setter
 * on the following function:
 * @dontinclude panes_example.c
 * @skipline static double
 * @skip static void
 * @skip }
 * @skip static void
 * @skip }
 * @skip static void
 * @skip }
 * @skipline static void
 * @until }
 * @until }
 * @until }
 *
 * Adding the callback function to the panes:
 * @skipline "clicked,double"
 * @until panes);
 *
 * See the full @ref panes_example.c "example", whose window should
 * look like this picture:
 *
 * @image html screenshots/panes_example.png
 * @image latex screenshots/panes_example.eps width=\textwidth
 *
 * @example panes_example.c
 */

/**
 * @page clock_example Clock widget example
 *
 * This code places five Elementary clock widgets on a window, each of
 * them exemplifying a part of the widget's API.
 *
 * The first of them is the pristine clock:
 * @dontinclude clock_example.c
 * @skip pristine
 * @until evas_object_show
 * As you see, the defaults for a clock are:
 * - military time
 * - no seconds shown
 *
 * For am/pm time, see the second clock:
 * @dontinclude clock_example.c
 * @skip am/pm
 * @until evas_object_show
 *
 * The third one will show the seconds digits, which will flip in
 * synchrony with system time. Note, besides, that the time itself is
 * @b different from the system's -- it was customly set with
 * elm_clock_time_set():
 * @dontinclude clock_example.c
 * @skip with seconds
 * @until evas_object_show
 *
 * In both fourth and fifth ones, we turn on the <b>edition
 * mode</b>. See how you can change each of the sheets on it, and be
 * sure to try holding the mouse pressed over one of the sheet
 * arrows. The forth one also starts with a custom time set:
 * @dontinclude clock_example.c
 * @skip in edition
 * @until evas_object_show
 *
 * The fifth, besides editable, has only the time @b units editable,
 * for hours, minutes and seconds. This exemplifies
 * elm_clock_edit_mode_set():
 * @dontinclude clock_example.c
 * @skip but only
 * @until evas_object_show
 *
 * See the full @ref clock_example.c "example", whose window should
 * look like this picture:
 *
 * @image html screenshots/clock_example.png
 * @image latex screenshots/clock_example.eps width=\textwidth
 *
 * See the full @ref clock_example_c "source code" for this example.
 *
 */

/**
 * @page datetime_example Datetime widget example
 *
 * This code places three Elementary Datetime widgets on a window, each of
 * them exemplifying the widget's different usage.
 *
 * The first of them is <b>"only Date display"</b>:
 * @dontinclude datetime_example.c
 * @skip only DATE
 * @until evas_object_show
 *
 * For <b>"only Time display"</b>, see the second datetime:
 * @dontinclude datetime_example.c
 * @skip only TIME
 * @until evas_object_show
 *
 * The third one will display datetime shows both <b>Date and Time</b>, corresponding format will be
 * taken from system @b locale. Note, besides, that the strings are different
 *  for different language settings.
 *
 * <b>Datetime format</b> can be programmatically set by using
 * elm_datetime_format_set():
 * @dontinclude datetime_example.c
 * @skip DATE and TIME
 * @until evas_object_show
 * The default format of any locale consists:
 * - Year Field
 * - Month Field
 * - Date Field
 * - Hour Field(12hr/24hr format)
 * - Minute Field
 * - AM/PM (if exists).
 *
 * This is how the example program's window looks like with the datetime widget
 * showing only date, only time and both date & time:
 *
 * @image html screenshots/datetime_example.png
 * @image latex screenshots/datetime_example.eps width=\textwidth
 *
 * See the full @ref datetime_example_c "source code" for
 * this example.
 *
 */

/**
 * @page dayselector_example Dayselector widget example
 *
 * This code places two Elementary dayselector widgets on a window, each of
 * them exemplifying the different widget styles.
 *
 * The first of them is the dayselector in default style:
 * @dontinclude dayselector_example.c
 * @skip weekdays starting from Sunday
 * @until evas_object_show
 *
 * As you see, the default style displays the weekdays starting from Sunday.
 *
 * One can select/unselect a day just by clicking on the day object.
 * The selection toggles once it is being pressed.
 *
 *
 * For showing weekdays starting from Monday, see the second dayselector:
 * @dontinclude dayselector_example.c
 * @skip weekdays starting from Monday
 * @until evas_object_show
 *
 *
 * The following code exemplifies the selection APIs of Dayselector:
 * @dontinclude dayselector_example.c
 * @skip Callback function
 * @until End of clicked callback
 *
 *
 * See the full @ref dayselector_example.c "example", whose window should
 * look like this picture:
 *
 * @image html screenshots/dayselector_example.png
 * @image latex screenshots/dayselector_example.eps width=\textwidth
 *
 * See the full @ref dayselector_example_c "source code" for this example.
 *
 */

/**
 * @page mapbuf_example Mapbuf Widget Example
 *
 * This code places an Elementary mapbuf widget on a window,
 * to exemplify part of the widget's API.
 *
 * First we'll add an window with a background and a vertical box to
 * pack our interface elements:
 * @dontinclude mapbuf_example.c
 * @skipline win_add
 * @until show(bx)
 *
 * Next we'll simply add the mapbuf widget to the box:
 * @skipline mapbuf_add
 * @until pack_end
 *
 * But mapbuf is a container widget, it won't do anything alone. So let's
 * create a table full of icons. For that we'll loop to fill each line of each
 * column. See @ref tutorial_table_01 "tutorial_table_01"
 * if you don't know how to use tables:
 * @skipline table_add
 * @until }
 * @until }
 *
 * Finally, setting mapbuf content:
 * @skipline content_set
 * @skipline show
 *
 * Also, would be good a horizontal box with some controls to change mapbuf
 * behavior:
 * @skipline box_add
 * @until show
 *
 * By default map is disabled. So just setting content isn't enough.
 * Alpha and smooth settings will be applied when map is enabled.
 * So we'll add a check for that. Everytime the map properties
 * are changed, map will need to be enabled again. So if you
 * want to play a bit with our example, remember to always enable
 * map again after concluding your changes.
 * @skipline check_add
 * @until show
 *
 * We have added a callback function to this check, so it will enable
 * or disable map:
 * @dontinclude mapbuf_example.c
 * @skip static
 * @skip }
 * @skipline static
 * @until }
 *
 * Let's add check boxes for alpha blending and smooth rendering:
 * @skipline check_add
 * @until show
 * @until show
 *
 * By default, mapbuf would enable alpha blending and smooth rendering,
 * so we need to check boxes to be consistent with its behavior.
 *
 * Callback functions look like the one added to the check. This way we
 * could enable or disable the both properties:
 * @dontinclude mapbuf_example.c
 * @skip static
 * @skip }
 * @skip static
 * @skip }
 * @skipline static
 * @until }
 * @until }
 *
 * You'll see that disabling alpha blending will set a black rectangle below
 * the icons. That's the reason you only should enable that when you're sure
 * the mapbuf content is 100% solid.
 *
 * See @ref mapbuf_example.c "mapbuf_example.c", whose window should
 * look like this picture:
 *
 * @image html screenshots/mapbuf_example.png
 * @image latex screenshots/mapbuf_example.eps width=\textwidth
 *
 * @example mapbuf_example.c
 */

/**
 * @page map_example_01 Map Example - Creation and Zoom
 *
 * This code places an Elementary map widget on a window,
 * to exemplify part of the widget's API.
 *
 * Let's start adding a map to our window:
 * @dontinclude map_example_01.c
 * @skipline elm_map_add
 * @until evas_object_show
 *
 * It's enough to display a world map inside our window. But usually you'll
 * need to let user interact with the map. We need to place some buttons,
 * so the user could control the map. It's done on the following code.
 * If you don't know about boxes, or buttons, check their examples,
 * @ref box_example_01 "Box Example 1" and
 * @ref button_example_01 "Button Example 1".
 * @skipline elm_box_add
 * @until _bt_zoom_fill
 *
 * We are adding callback functions that will be called when the user clicks
 * over these buttons. Let's study such functions, starting from the function
 * that will zoom in the map:
 * @dontinclude map_example_01.c
 * @skipline static void
 * @until }
 *
 * First thing done is assure zoom mode is set to manual. It's the default
 * mode, but the other buttons will change this, so before setting a new
 * zoom value, we need to change the zoom mode.
 *
 * Then, we get the current zoom value, increment that, and set the new
 * value to the map. If it's bigger than max zoom value allowed, it will
 * remain on the maximum allowed, nothing bad will happen. This way we
 * don't need to check first if it won't be bigger than max.
 *
 * Zoom out function is basically the same thing, but zoom will be decremented
 * instead of incremented:
 * @skipline static void
 * @until }
 *
 * The "X" button, when pressed, will call a function that will
 * zoom the map until it fits
 * inside the scroll frame with no pixels outside this area:
 * @skipline static void
 * @until }
 *
 * And the "#" button, will call a function that will zoom until map fills
 * scroll, ensuring no pixels are left unfilled:
 * @skipline static void
 * @until }
 *
 * But we can also set map to show something different from default
 * world map, changing the zoom level and region shown. Let's pick a
 * wonderful city coordinates, one placed at <tt> 43 20 S, 22 90 W </tt>.
 * Since map uses double variables to represent latitude and longitude,
 * to represent north or east, we should represent it as positive values,
 * and south or west as negative. Also, the value will be represented as
 * degree.min. So, for example, our longitude <tt> 43 20 S </tt> will
 * be represented
 * by the value <tt> -43.20 </tt>. A zoom set to @c 12 should be enough
 * to show a city.
 * @skipline region_show
 * @until zoom_set
 *
 * See @ref map_example_01.c "map_example_01.c" for full source,
 * whose window should
 * look like this picture:
 *
 * @image html screenshots/map_example_01.png
 * @image latex screenshots/map_example_01.eps width=\textwidth
 *
 * @example map_example_01.c
 */

/**
 * @page map_example_02 Map Example - Overlay Usage
 *
 * This code places an Elementary map widget on a window,
 * to exemplify part of the widget's API, related to overlays.
 *
 * We'll start this example in the same way as
 * @ref map_example_01 "Map Example 1". Adding a map with buttons to control
 * zoom, so if you didn't read it yet, just do it now.
 * @dontinclude map_example_02.c
 * @skipline elm_map_add
 * @until zoom_fill
 *
 * Overlays can be placed over the map to represent anything we want. Let's
 * say we want to represent some countries and cities with overlays.
 *
 * Before we create city or country overlays, let's create class overlays.
 *
 * @skipline elm_map_overlay_class_add
 * @until elm_map_overlay_icon_set
 * These lines create a class overlay which represents cities.
 * This class overlay will be used for grouping city overlays.
 * Later city overlays in the same class are appended to this class overlay.
 * if city overlays are near each other, they will be grouped.
 *
 * We can set the icon for the class so that the icon will be displayed
 * when city overlays are grouped.
 * We can set the zoom required to display the overlays that belongs
 * to this class, so if the zoom is less than this value, nothing
 * will be shown.
 *
 * Country class can be created in the same way.
 * @skipline elm_map_overlay_class_add
 * @until elm_map_overlay_icon_set
 *
 * Next we'll create some overlays representing cities and countries.
 * We set the data for the overlay so that can be used later when
 * clicked callback is called.
 * We'll append them into city class to be grouped.
 * We'll append them in a list, to close up them later.
 * To create a default overlay, we need to pass the coordinates.
 * @skipline elm_map_overlay_add
 * @until eina_list_append
 *
 * We subscribe a smart callback "overlay,clicked" to create bubble on
 * the clicked overlay.
 * @dontinclude map_example_02.c
 * @skipline "overlay,clicked"
 *
 * Finally, on our @c main function, we ask the map to show all the overlays
 * with the biggest zoom possible, passing the list of overlays added.
 * @skipline elm_map_overlays_show
 *
 * We have created a specific structure for this example to store the name
 * of the place and a path to a image file to represent it.
 * @dontinclude map_example_02.c
 * @skipline typedef
 * @until Overlay_Data;
 *
 * We'll create instances for each place:
 * @skipline argentina
 * @until sky_03
 *
  * To return an icon, all we need to do is to add a elm_icon and return it:
 * @dontinclude map_example_02.c
 * @skipline _icon_get(
 * @until }
 *
 * For the content, let's return something more elaborate. We will return
 * a box with an image representing the place, and the name of this place:
 * @skipline _box_get(
 * @until }
 *
 * See @ref map_example_02.c "map_example_02.c" for full source,
 * whose window should
 * look like this picture:
 *
 * @image html screenshots/map_example_02.png
 * @image latex screenshots/map_example_02.eps width=\textwidth
 *
 * @example map_example_02.c
 */

/**
 * @page map_example_03 Map Example - Route and Name Usage
 *
 * This code places an Elementary map widget on a window,
 * to exemplify part of the widget's API, related routes and names.
 *
 * In this example, we will suppose we need to set a route for the user
 * from his current point (a gps could provide us this information)
 * to somewhere else. So we would have coordinates of this
 * start point, and would like that he enters the address of his
 * destination in a entry, and we'll trace a route on the map.
 *
 * We'll start this example in the same way
 * @ref map_example_01 "Map Example 1". Adding a map with buttons to control
 * zoom, so if you didn't read it yet, just do it now. Actually there is
 * a change, that we're aligning buttons to the top, since we wan't a
 * vertical control box this time.
 * @dontinclude map_example_03.c
 * @skipline elm_map_add
 * @until zoom_fill
 * @until align_set
 *
 * Next we set the box to be vertical and change it's size, weight
 * and alignment, so it will occupy the top of the window, from left
 * to right:
 * @skipline horizontal_set
 * @until align_set
 *
 * We'll add an entry with a preliminar address, that I know will
 * find a coordinate, to examplify names work. But you can try
 * lots of addresses. From city or country names to pubs, or whatever
 * you want. To try is enough to run the example, type the address and
 * press "Route" button. This button will call a function that will
 * get the typed address and find the route.
 * @skipline entry_add
 * @until align_set
 * @until align_set
 *
 * The button pass an structure
 * instance we make for this example, with all the fields we'll need.
 * @dontinclude map_example_03.c
 * @skipline _Example_Data
 * @until example_data;
 *
 * Let's initialize it's fields:
 * @skipline example_data.map
 * @until example_data.start_lat
 *
 * @c map and @c entry are our elementary objects, @c route is set to @c NULL,
 * since we don't have one yet, and the coordinates of the start point is set
 * (longitude and latitude).
 *
 * Also, let's show this start point at the center of the map, and set a zoom
 * nice enough to close it:
 * @skipline region_show
 * @until zoom_set
 *
 * These lines were already explained on @ref map_example_02 "Map Example 2".
 *
 * Now we'll see the "Route" button callback function:
 * @dontinclude map_example_03.c
 * @skip static void
 * @skip }
 * @skipline static void
 * @until }
 *
 * First we get the address string from our entry. Then we use @c name
 * conversion
 * util functions, so we could get coordinates for this address. These
 * functions return an #Elm_Map_Name handle for us.
 * Function elm_map_name_geo_request() will do this job for us,
 * but it's an asynchronous function, since it requires this
 * information from the server.
 *
 * That's the reason we need to wait for
 * <tt> "name,loaded" </tt> signal. We add a callback function for this:
 * @dontinclude map_example_03.c
 * @skipline static void
 * @until }
 *
 * This function will check if a previous route was traced, and if it was,
 * it will remove it. Next we'll get destination coordinates from our
 * @c name, and use them to add a new route.
 *
 * To trace a route we need to know how the user will go through the path.
 * Let's suppose he'll be walking, but doesn't like to walk, so we
 * need to choose the shortest path instead of the route that would
 * made him spend less time. Coordinates of the point from where he will
 * start and of the destination point need to be passed as well.
 *
 * Finally we'll set a color different from solid red (default), to show
 * our route. We set it green.
 *
 * See @ref map_example_03.c "map_example_03.c" for full source,
 * whose window should
 * look like this picture:
 *
 * @image html screenshots/map_example_03.png
 * @image latex screenshots/map_example_03.eps width=\textwidth
 *
 * @example map_example_03.c
 */

/**
 * @page diskselector_example_01 Diskselector widget example
 *
 * This code places 4 Elementary diskselector widgets on a window, each of
 * them exemplifying a part of the widget's API.
 *
 * All of them will have weekdays as items, since we won't focus
 * on items management on this example. For an example about this subject,
 * check @ref diskselector_example_02.
 *
 * The first of them is a default diskselector.
 * @dontinclude diskselector_example_01.c
 * @skipline lbl
 * @until }
 * @skipline elm_diskselector_add
 * @until evas_object_show
 *
 * We are just adding the diskselector, so as you can see, defaults for it are:
 * @li Only 3 items visible each time.
 * @li Only 3 characters are displayed for labels on side positions.
 * @li The first added item remains centeres, i.e., it's the selected item.
 *
 * To add items, we are just appending it on a loop, using function
 * elm_diskselector_item_append(), that will be better explained on
 * items management example.
 *
 * For a circular diskselector, check the second widget. A circular
 * diskselector will display first item after last, and last previous to
 * the first one. So, as you can see, @b Sa will appears on left side
 * of selected @b Sunday. This property is set with
 * elm_diskselector_round_enabled_set().
 *
 * Also, we decide to display only 2 character for side labels, instead of 3.
 * For this we call elm_diskselector_side_text_max_length_set(). As result,
 * we'll see @b Mo displayed instead of @b Mon, when @b Monday is on a
 * side position.
 *
 * @skipline elm_diskselector_add
 * @until evas_object_show
 *
 * But so far, we are only displaying 3 items at once. If more are wanted,
 * is enough to call elm_diskselector_display_item_num_set(), as you can
 * see here:
 * @skipline elm_diskselector_add
 * @until elm_diskselector_display_item_num_set
 *
 * @note You can't set less than 3 items to be displayed.
 *
 * You can get the number of items in the diskselector by calling
 * elm_diskselector_display_item_num_get(), as you can see here:
 * @skipline elm_diskselector_display_item_num_get
 *
 * Finally, if a bounce effect is required, or you would like to see
 * scrollbars, it is possible. But, for default theme, diskselector
 * scrollbars will be invisible anyway.
 * @skipline elm_diskselector_add
 * @until evas_object_show
 *
 * See the full @ref diskselector_example_01.c "diskselector_example_01.c"
 * code, whose window should look like this picture:
 *
 * @image html screenshots/diskselector_example_01.png
 * @image latex screenshots/diskselector_example_01.eps width=\textwidth
 *
 * @example diskselector_example_01.c
 */

/**
 * @page diskselector_example_02 Diskselector - Items management
 *
 * This code places an Elementary diskselector widgets on a window,
 * along with some buttons trigerring actions on it (though its API).
 * It covers most of diskselector item functions.
 *
 * On our @c main function, we are adding a default diskselector with
 * 3 items. We are only setting their labels (second parameter of function
 * elm_diskselector_item_append):
 * @dontinclude diskselector_example_02.c
 * @skipline elm_diskselector_add
 * @until Item 2
 *
 * Next we are adding lots of buttons, each one for a callback function
 * that will realize a task covering part of diskselector items API.
 * Lets check the first one:
 * @skipline elm_button_add
 * @until evas_object_show
 *
 * We are labeling the button with a task description with
 * elm_object_text_set() and setting a callback
 * function evas_object_smart_callback_add().
 * Each callback function will have the signature:
 * <tt> static void _task_cb(void *data, Evas_Object *obj,
 * void *event_info)</tt> with the function name varying for each task.
 *
 * Now let's cover all of them.
 *
 * <b> Appending an item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _add_cb
 * @until }
 *
 * All items are included on diskselector after last one. You @b can't
 * prepend items.
 *
 * The first parameter of elm_diskselector_item_append() is the diskselector
 * object, that we are receiving as data on our callback function.
 * The second one is a label, the string that will be placed in the center
 * of our item. As we don't wan't icons or callback functions, we can
 * send NULL as third, fourth and fifth parameters.
 *
 * <b> Appending an item with icon: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _add_ic_cb
 * @until }
 *
 * If an icon is required, you can pass it as third parameter on our
 * elm_diskselector_item_append() function. It will be place on the
 * left side of item's label, that will be shifted to right a bit.
 *
 * For more details about how to create icons, look for elm_icon examples.
 *
 * <b> Appending an item with callback function for selected: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _sel_cb
 * @until }
 * @until }
 *
 * To set a callback function that will be called every time an item is
 * selected, i.e., everytime the diskselector stops with this item in
 * center position, just pass the function as fourth parameter.
 *
 * <b> Appending an item with callback function for selected with data: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _sel_data_cb
 * @until }
 * @until }
 * @until }
 * @until }
 *
 * If the callback function request an extra data, it can be attached to our
 * item passing a pointer for data as fifth parameter.
 * Our function _sel_data_cb will receive it as <tt> void *data </tt>.
 *
 * If you want to free this data, or handle that the way you need when the
 * item is deleted, set a callback function for that, with
 * elm_object_item_del_cb_set().
 *
 * As you can see we check if @c it is not @c NULL after appending it.
 * If an error happens, we won't try to set a function for it.
 *
 * <b> Deleting an item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _del_cb(void
 * @until }
 *
 * To delete an item we simple need to call elm_object_item_del() with
 * a pointer for such item.
 *
 * If you need, you can get selected item with
 * elm_diskselector_selected_item_get(), that will return a pointer for it.
 *
 * <b> Unselecting an item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _unselect_cb
 * @until }
 *
 * To select an item, you should call elm_diskselector_item_selected_set()
 * passing @c EINA_TRUE, and to unselect it, @c EINA_FALSE.
 *
 * If you unselect the selected item, diskselector will automatically select
 * the first item.
 *
 * <b> Printing all items: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _print_cb
 * @until }
 *
 * <b> Clearing the diskselector: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _clear_cb
 * @until }
 *
 * <b> Selecting the first item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _select_first_cb
 * @until }
 *
 * <b> Selecting the last item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _select_last_cb
 * @until }
 *
 * <b> Selecting the next item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _select_next_cb
 * @until }
 *
 * <b> Selecting the previous item: </b>
 * @dontinclude diskselector_example_02.c
 * @skipline _select_prev_cb
 * @until }
 *
 * See the full @ref diskselector_example_02.c "diskselector_example_02.c"
 * code, whose window should look like this picture:
 *
 * @image html screenshots/diskselector_example_02.png
 * @image latex screenshots/diskselector_example_02.eps width=\textwidth
 *
 * @example diskselector_example_02.c
 */

/**
 * @page list_example_01 List widget example
 *
 * This code places a single Elementary list widgets on a window, just
 * to exemplify the more simple and common use case: a list will be created
 * and populated with a few items.
 *
 * To keep it simple, we won't show how to customize the list, for this check
 * @ref list_example_02. Also, we won't focus
 * on items management on this example. For an example about this subject,
 * check @ref list_example_03.
 *
 * To add a list widget.
 * @dontinclude list_example_01.c
 * @skipline elm_list_add
 *
 * We are just adding the list, so as you can see, defaults for it are:
 * @li Items are displayed vertically.
 * @li Only one item can be selected.
 * @li The list doesn't bounce.
 *
 * To add items, we are just appending it on a loop, using function
 * elm_list_item_append(), that will be better explained on
 * items management example.
 * @dontinclude list_example_01.c
 * @skipline lbl[]
 * @until };
 * @skipline for
 * @skipline elm_list_item_append
 *
 * After we just want to show the list. But first we need to start the widget.
 * It was done this way to improve widget's performance. So, always remember
 * that:
 * @warning Call elm_list_go before showing the object
 * @skipline elm_list_go
 * @skipline show
 *
 * See the full @ref list_example_01.c "list_example_01.c"
 * code, whose window should look like this picture:
 *
 * @image html screenshots/list_example_01.png
 * @image latex screenshots/list_example_01.eps width=\textwidth
 *
 * @example list_example_01.c
 */

/**
 * @page list_example_02 List widget example
 *
 * This code places a single Elementary list widgets on a window,
 * exemplifying a part of the widget's API.
 *
 * First, we will just create a simple list, as done on @ref list_example_01 :
 * @dontinclude list_example_02.c
 * @skipline lbl
 * @until }
 * @skipline elm_list_add
 * @until elm_list_item_append
 *
 * Now, let's customize this list a bit. First we will display items
 * horizontally:
 * @skipline horizontal_set
 *
 * Then we will choose another list mode. There are four of them, and
 * the default #Elm_List_Mode is #ELM_LIST_SCROLL. Let's set compress mode:
 * @skipline mode_set
 *
 * To enable multiple items selection, we need to enable it, since only one
 * selected item is allowed by default:
 * @skipline elm_list_multi_select_set
 *
 * We are not adding items with callback functions here,
 * since we'll explain it better on  @ref list_example_03. But if the callback
 * need to be called everytime user clicks an item, even if already selected,
 * it's required to enable this behavior:
 * @skipline elm_list_select_mode_set
 *
 * Finally, if a bounce effect is required, or you would like to see
 * scrollbars, it is possible. But, for default theme, list
 * scrollbars will be invisible anyway.
 * @skipline bounce_set
 * @until SCROLLER_POLICY_ON
 *
 * See the full @ref list_example_02.c "list_example_02.c"
 * code, whose window should look like this picture:
 *
 * @image html screenshots/list_example_02.png
 * @image latex screenshots/list_example_02.eps width=\textwidth
 *
 * @example list_example_02.c
 */

/**
 * @page list_example_03 List - Items management
 *
 * This code places an Elementary list widgets on a window,
 * along with some buttons trigerring actions on it (though its API).
 * It covers most of elm_list_item functions.
 *
 * On our @c main function, we are adding a default list with
 * 3 items. We are only setting their labels (second parameter of function
 * elm_list_item_append):
 * @dontinclude list_example_03.c
 * @skipline elm_list_add
 * @until Item 2
 *
 * Next we are adding lots of buttons, each one for a callback function
 * that will realize a task covering part of list items API.
 * Lets check the first one:
 * @skipline elm_button_add
 * @until evas_object_show
 *
 * We are labeling the button with a task description with
 * elm_object_text_set() and setting a callback
 * function evas_object_smart_callback_add().
 * Each callback function will have the signature:
 * <tt> static void _task_cb(void *data, Evas_Object *obj,
 * void *event_info)</tt> with the function name varying for each task.
 *
 * Now let's cover all of them.
 *
 * <b> Prepending an item: </b>
 * @dontinclude list_example_03.c
 * @skipline _prepend_cb
 * @until }
 *
 * The item will be placed on the beginning of the list,
 * i.e. it will be the first one.
 *
 * The first parameter of elm_list_item_prepend() is the list
 * object, that we are receiving as data on our callback function.
 * The second one is a label, the string that will be placed in the center
 * of our item. As we don't wan't icons or callback functions, we can
 * send NULL as third, fourth, fifth and sixth parameters.
 *
 * <b> Appending an item: </b>
 * @dontinclude list_example_03.c
 * @skipline _add_cb
 * @until }
 *
 * Items included with append will be inserted inserted after the last one.
 *
 * <b> Appending an item with icon: </b>
 * @dontinclude list_example_03.c
 * @skipline _add_ic_cb
 * @until }
 *
 * If an icon is required, you can pass it as third parameter on our
 * elm_list_item_append() function. It will be place on the
 * left side of item's label. If an icon is wanted on the right side,
 * it should be passed as fourth parameter.
 *
 * For more details about how to create icons, look for elm_icon examples
 * @ref tutorial_icon.
 *
 * <b> Appending an item with callback function for selected: </b>
 * @dontinclude list_example_03.c
 * @skipline _sel_cb
 * @until }
 * @until }
 *
 * To set a callback function that will be called every time an item is
 * selected, i.e., everytime the list stops with this item in
 * center position, just pass the function as fifth parameter.
 *
 * <b> Appending an item with callback function for selected with data: </b>
 * @dontinclude list_example_03.c
 * @skipline _sel_data_cb
 * @until }
 * @until }
 * @until }
 * @until }
 *
 * If the callback function request an extra data, it can be attached to our
 * item passing a pointer for data as sixth parameter.
 * Our function _sel_data_cb will receive it as <tt> void *data </tt>.
 *
 * If you want to free this data, or handle that the way you need when the
 * item is deleted, set a callback function for that, with
 * elm_object_item_del_cb_set().
 *
 * As you can see we check if @c it is not @c NULL after appending it.
 * If an error happens, we won't try to set a function for it.
 *
 * <b> Deleting an item: </b>
 * @dontinclude list_example_03.c
 * @skipline _del_cb(
 * @until }
 *
 * To delete an item we simple need to call elm_object_item_del() with
 * a pointer for such item.
 *
 * If you need, you can get selected item with
 * elm_list_selected_item_get(), that will return a pointer for it.
 *
 * <b> Unselecting an item: </b>
 * @dontinclude list_example_03.c
 * @skipline _unselect_cb
 * @until }
 *
 * To select an item, you should call elm_list_item_selected_set()
 * passing @c EINA_TRUE, and to unselect it, @c EINA_FALSE.
 *
 * <b> Printing all items: </b>
 * @dontinclude list_example_03.c
 * @skipline _print_cb
 * @until }
 *
 * <b> Clearing the list: </b>
 * @dontinclude list_example_03.c
 * @skipline _clear_cb
 * @until }
 *
 * <b> Selecting the next item: </b>
 * @dontinclude list_example_03.c
 * @skipline _select_next_cb
 * @until }
 *
 * <b> Inserting after an item: </b>
 * @dontinclude list_example_03.c
 * @skipline _insert_after_cb
 * @until }
 *
 * <b> Selecting the previous item: </b>
 * @dontinclude list_example_03.c
 * @skipline _select_prev_cb
 * @until }
 *
 * <b> Inserting before an item: </b>
 * @dontinclude list_example_03.c
 * @skipline _insert_before_cb
 * @until }
 *
 * If a separator is required, just set an item as such:
 * @dontinclude list_example_03.c
 * @skipline _set_separator_cb
 * @until }
 *
 * Also an item can be disabled, and the user won't be allowed to (un)select it:
 * @dontinclude list_example_03.c
 * @skipline _disable_cb
 * @until }
 *
 * See the full @ref list_example_03.c "list_example_03.c"
 * code, whose window should look like this picture:
 *
 * @image html screenshots/list_example_03.png
 * @image latex screenshots/list_example_03.eps width=\textwidth
 *
 * @example list_example_03.c
 */

/**
 * @page toolbar_example_01 Toolbar Example - Simple Items
 *
 * This code places an Elementary toolbar widget on a window,
 * to exemplify part of the widget's API.
 *
 * Let's start adding a button to our window, that will have its text
 * modified depending on which item is selected. It's used just to exemplify
 * how to change a window content from the toolbar.
 * @dontinclude toolbar_example_01.c
 * @skipline elm_button_add
 * @until evas_object_show
 *
 * Also, we'll need a toolbar widget, obviously:
 * @skipline elm_toolbar_add
 * @until evas_object_show
 *
 * When appending an item is possible to set an icon, label, and a callback
 * function that will receive passed data.
 * @skipline _item_append
 * @until Folder
 *
 * It's possible to disable items, so the user can't select then. We will
 * disable the third item:
 * @skipline _item_append
 * @until disable
 *
 * Our callbacks will just set button's label:
 * @dontinclude toolbar_example_01.c
 * @skip static
 * @skip }
 * @skipline static
 * @until }
 * @until }
 * @until }
 *
 * By default, toolbars would display items homogeneously, so item with
 * long labels, like the third, will make all of them occupy a lot of space.
 * To avoid that, we can disable it:
 * @dontinclude toolbar_example_01.c
 * @skipline homogeneous
 *
 * Another default behavior, is to add an menu item if we have more items
 * that would fit on toolbar size. To simply enable scroll, without menus,
 * it's required to change toolbar's shrink mode:
 * @dontinclude toolbar_example_01.c
 * @skipline shrink
 *
 * See @ref toolbar_example_01.c "toolbar_example_01.c", whose window should
 * look like this picture:
 *
 * @image html screenshots/toolbar_example_01.png
 * @image latex screenshots/toolbar_example_01.eps width=\textwidth
 *
 * @example toolbar_example_01.c
 */

/**
 * @page toolbar_example_02 Toolbar Example - Items with States
 *
 * This code places an Elementary toolbar widget on a window,
 * to exemplify part of the widget's API.
 *
 * Toolbar widgets has support to items with states. Each state
 * can have it's own label, icon, and callback function.
 *
 * Let's start populating a toolbar with some regular items.
 * If you don't know how to do that, see
 * @ref toolbar_example_01 "Toolbar Example 1".
 * @dontinclude toolbar_example_02.c
 * @skipline elm_toolbar_add
 * @until Update
 *
 * The only difference here is that we set shrink mode to #ELM_TOOLBAR_SHRINK_HIDE,
 * that won't display items that doesn't fit to the window.
 *
 * Now, let's add an item with states. First, add the item just as any other.
 * @skipline elm_toolbar_item_append
 * @until _item_pressed
 *
 * After that states can be added to this item:
 * @skipline state_add
 * @until Full
 * @until _item_pressed
 *
 * The both states and the item are using the same callback function,
 * that will cycle between states and unselect the item. Unseleting
 * is required because it won't call the callback if an user clicks
 * over an item already selected:
 * @dontinclude toolbar_example_02.c
 * @skip static
 * @skip }
 * @skipline static
 * @until }
 *
 * On our example, some items are hidden
 * because we set the window to be small. But if an item should be displayed
 * anyway, is needed to set its priority to be higher than others.
 * Any positive value will be enough in our case. Let's force the item
 * with multiple states to be displayed.
 * @skipline priority
 *
 * See @ref toolbar_example_02.c "toolbar_example_02.c", whose window should
 * look like this picture:
 *
 * @image html screenshots/toolbar_example_02.png
 * @image latex screenshots/toolbar_example_02.eps width=\textwidth
 *
 * @example toolbar_example_02.c
 */

/**
 * @page toolbar_example_03 Toolbar Example - Items with Menus
 *
 * Toolbar widgets have support to items with menus. This kind
 * of item will display a menu when selected by the user.
 *
 * Let's start populating a toolbar with some regular items, the same
 * way we started @ref toolbar_example_02 "Toolbar Example 2".
 * @dontinclude toolbar_example_03.c
 * @skipline elm_toolbar_add
 * @until Update
 *
 * The only difference is that we'll keep the default shrink mode, that
 * adds an item with a menu of hidden items.
 *
 * So, a important thing to do is to set a parent for toolbar menus, or they
 * will use the toolbar as parent, and its size will be restricted to that.
 * @skipline parent_set
 *
 * Not only items' menus will respect this parent, but also the own toolbar
 * menu, used to show hidden items.
 *
 * Next, let's add an item set to display a menu:
 * @skipline elm_toolbar_item_append
 * @until _menu_set
 *
 * Now, to add two options to this item, we can get the menu object and use
 * it as a regular elm_menu. See @ref tutorial_menu "Menu example" for more
 * about menu widget.
 * @skipline _menu_get
 * @until Full
 *
 * See @ref toolbar_example_03.c "toolbar_example_03.c", whose window should
 * look like this picture:
 *
 * @image html screenshots/toolbar_example_03.png
 * @image latex screenshots/toolbar_example_03.eps width=\textwidth
 *
 * @example toolbar_example_03.c
 */

/**
 * @page segment_control_example Segment Control Example
 *
 * This code places an Elementary segment control widgets on a window,
 * to exemplify part of the widget's API.
 *
 * Let's start adding a segment control to our window:
 * @dontinclude segment_control_example.c
 * @skipline elm_segment_control_add
 * @until evas_object_show
 *
 * Now will add an item only with label:
 * @skipline item_add
 *
 * Really simple. To add an item with only an icon, the icon needs to be created
 * first, them added with this same function:
 * @skipline icon_add
 * @until item_add
 *
 * If an item with label and icon is required, it can be done as well. In this
 * case, instead of a label (or icon) centered, the item will display an icon
 * at left and the label at right:
 * @skipline icon_add
 * @until item_add
 *
 * But, if you need to add some items that can have or not a label, but
 * want that all of them looks the same way, with icon at left, just add
 * an empty string label. It's done on our example to illustrate that:
 * @skipline icon_add
 * @until item_add
 *
 * So far, all the item were added to the last position of the widget,
 * but if something different is required, it can be done using another
 * insertion function. Let's suppose we want to put an item just before
 * the last item:
 * @skipline count
 * @until insert_at
 *
 * There are two ways to delete items. Using the item handle, like:
 * @skipline insert_at
 * @until del
 *
 * Or using item's index:
 * @skipline insert_at
 * @until del_at
 *
 * To set properties of an item already added to the widget, you just need
 * to get the item and set icon or label, as the following code shows:
 * @skipline item_get
 * @until label_set
 *
 * Finally, it's possible to select an item from the code, and also get
 * the selected item. We will select the item at the center of the widget
 * and print its position.
 * @skipline count_get
 * @until printf
 *
 * See the full @ref segment_control_example.c "example", whose window should
 * look like this picture:
 *
 * @image html screenshots/segment_control_example.png
 * @image latex screenshots/segment_control_example.eps width=\textwidth
 *
 * @example segment_control_example.c
 */

/**
 * @page flipselector_example Flip selector widget example
 *
 * This code places an Elementary flip selector widget on a window,
 * along with two buttons trigerring actions on it (though its API).
 *
 * The selector is being populated with the following items:
 * @dontinclude flipselector_example.c
 * @skip lbl[]
 * @until ;
 *
 * Next, we create it, populating it with those items and registering
 * two (smart) callbacks on it:
 * @dontinclude flipselector_example.c
 * @skip fp = elm_flipselector_add
 * @until object_show
 *
 * Those two callbacks will take place whenever one of those smart
 * events occur, and they will just print something to @c stdout:
 * @dontinclude flipselector_example.c
 * @skip underflow callback
 * @until }
 * @until }
 * Flip the sheets on the widget while looking at the items list, in
 * the source code, and you'll get the idea of those events.
 *
 * The two buttons below the flip selector will take the actions
 * described in their labels:
 * @dontinclude flipselector_example.c
 * @skip bt = elm_button_add
 * @until callback_add(win
 *
 * @dontinclude flipselector_example.c
 * @skip unselect the item
 * @until }
 * @until }
 *
 * Click on them to exercise those flip selector API calls. To
 * interact with the other parts of this API, there's a command line
 * interface, whose help string can be asked for with the 'h' key:
 * @dontinclude flipselector_example.c
 * @skip commands
 * @until ;
 *
 * The 'n' and 'p' keys will exemplify elm_flipselector_flip_next()
 * and elm_flipselector_flip_prev(), respectively. 'f' and 'l' account
 * for elm_flipselector_first_item_get() and
 * elm_flipselector_last_item_get(), respectively. Finally, 's' will
 * issue elm_flipselector_selected_item_get() on our example flip
 * selector widget.
 *
 * See the full @ref flipselector_example.c "example", whose window should
 * look like this picture:
 *
 * @image html screenshots/flipselector_example.png
 * @image latex screenshots/flipselector_example.eps width=\textwidth
 *
 * See the full @ref flipselector_example_c "source code" for this example.
 *
 */

/**
 * @page fileselector_example File selector widget example
 *
 * This code places two Elementary file selector widgets on a window.
 * The one on the left is layouting file system items in a @b list,
 * while the the other is layouting them in a @b grid.
 *
 * The one having the majority of hooks of interest is on the left,
 * which we create as follows:
 * @dontinclude fileselector_example.c
 * @skip first file selector
 * @until object_show
 *
 * Note that we enable custom edition of file/directory selection, via
 * the text entry it has on its bottom, via
 * elm_fileselector_is_save_set(). It starts with the list view, which
 * is the default, and we make it not expandable in place
 * (elm_fileselector_expandable_set()), so that it replaces its view's
 * contents with the current directory's entries each time one
 * navigates to a different folder.  For both of file selectors we are
 * starting to list the contents found in the @c "/tmp" directory
 * (elm_fileselector_path_set()).
 *
 * Note the code setting it to "grid mode" and observe the differences
 * in the file selector's views, in the example. We also hide the
 * second file selector's Ok/Cancel buttons -- since it's there just
 * to show the grid view (and navigation) -- via
 * elm_fileselector_buttons_ok_cancel_set().
 *
 * The @c "done" event, which triggers the callback below
 * @dontinclude fileselector_example.c
 * @skip 'done' cb
 * @until }
 * will be called at the time one clicks the "Ok"/"Cancel" buttons of
 * the file selector (on the left). Note that it will print the path
 * to the current selection, if any.
 *
 * The @c "selected" event, which triggers the callback below
 * @dontinclude fileselector_example.c
 * @skip bt = 'selected' cb
 * @until }
 * takes place when one selects a file (if the file selector is @b not
 * under folders-only mode) or when one selects a folder (when in
 * folders-only mode). Experiment it by selecting different file
 * system entries.
 *
 * What comes next is the code creating the three check boxes and two
 * buttons below the file selector in the right. They will exercise a
 * bunch of functions on the file selector's API, for the instance on
 * the left. Experiment with them, specially the buttons, to get the
 * difference between elm_fileselector_path_get() and
 * elm_fileselector_selected_get().
 *
 * Finally, there's the code adding the second file selector, on the
 * right:
 * @dontinclude fileselector_example.c
 * @skip second file selector
 * @until object_show
 *
 * Pay attention to the code setting it to "grid mode" and observe the
 * differences in the file selector's views, in the example. We also
 * hide the second file selector's Ok/Cancel buttons -- since it's
 * there just to show the grid view (and navigation) -- via
 * elm_fileselector_buttons_ok_cancel_set().
 *
 * See the full @ref fileselector_example.c "example", whose window
 * should look like this picture:
 *
 * @image html screenshots/fileselector_example.png
 * @image latex screenshots/fileselector_example.eps width=\textwidth
 *
 * See the full @ref fileselector_example_c "source code" for this example.
 *
 */

/**
 * @page fileselector_button_example File selector button widget example
 *
 * This code places an Elementary file selector button widget on a
 * window, along with some other checkboxes and a text entry. Those
 * are there just as knobs on the file selector button's state and to
 * display information from it.
 *
 * Here's how we instantiate it:
 * @dontinclude fileselector_button_example.c
 * @skip ic = elm_icon_add
 * @until evas_object_show
 *
 * Note that we set on it both icon and label decorations. It's set to
 * list the contents of the @c "/tmp" directory, too, with
 * elm_fileselector_button_path_set(). What follows are checkboxes to
 * exercise some of its API funtions:
 * @dontinclude fileselector_button_example.c
 * @skip ck = elm_check_add
 * @until evas_object_show(en)
 *
 * The checkboxes will toggle whether the file selector button's
 * internal file selector:
 * - must have an editable text entry for file names (thus, be in
 *   "save dialog mode")
 * - is to be raised as an "inner window" (note it's the default
 *   behavior) or as a dedicated window
 * - is to populate its view with folders only
 * - is to expand its folders, in its view, <b>in place</b>, and not
 *   repainting it entirely just with the contents of a sole
 *   directory.
 *
 * The entry labeled @c "Last selection" will exercise the @c
 * "file,chosen" smart event coming from the file selector button:
 * @dontinclude fileselector_button_example.c
 * @skip hook on the
 * @until toggle inwin
 *
 * Whenever you dismiss or acknowledges the file selector, after it's
 * raised, the @c event_info string will contain the last selection on
 * it (if any was made).
 *
 * This is how the example, just after called, should look like:
 *
 * @image html screenshots/fileselector_button_example_00.png
 * @image latex screenshots/fileselector_button_example_00.eps width=\textwidth
 *
 * Click on the file selector button to raise its internal file
 * selector, which will be contained on an <b>"inner window"</b>:
 *
 * @image html screenshots/fileselector_button_example_01.png
 * @image latex screenshots/fileselector_button_example_01.eps width=\textwidth
 *
 * Toggle the "inwin mode" switch off and, if you click on the file
 * selector button again, you'll get @b two windows, the original one
 * (note the last selection there!)
 *
 * @image html screenshots/fileselector_button_example_02.png
 * @image latex screenshots/fileselector_button_example_02.eps width=\textwidth
 *
 * and the file selector's new one
 *
 * @image html screenshots/fileselector_button_example_03.png
 * @image latex screenshots/fileselector_button_example_03.eps width=\textwidth
 *
 * Play with the checkboxes to get the behavior changes on the file
 * selector button. The respective API calls on the widget coming from
 * those knobs where shown in the code already.
 *
 * See the full @ref fileselector_button_example_c "source code" for
 * this example.
 *
 */

/**
 * @page fileselector_entry_example File selector entry widget example
 *
 * This code places an Elementary file selector entry widget on a
 * window, along with some other checkboxes. Those are there just as
 * knobs on the file selector entry's state.
 *
 * Here's how we instantiate it:
 * @dontinclude fileselector_entry_example.c
 * @skip ic = elm_icon_add
 * @until evas_object_show
 *
 * Note that we set on it's button both icon and label
 * decorations. It's set to exhibit the path of (and list the contents
 * of, when internal file selector is launched) the @c "/tmp"
 * directory, also, with elm_fileselector_entry_path_set(). What
 * follows are checkboxes to exercise some of its API funtions:
 * @dontinclude fileselector_entry_example.c
 * @skip ck = elm_check_add
 * @until callback_add(fs_entry
 *
 * The checkboxes will toggle whether the file selector entry's
 * internal file selector:
 * - must have an editable text entry for file names (thus, be in
 *   "save dialog mode")
 * - is to be raised as an "inner window" (note it's the default
 *   behavior) or as a dedicated window
 * - is to populate its view with folders only
 * - is to expand its folders, in its view, <b>in place</b>, and not
 *   repainting it entirely just with the contents of a sole
 *   directory.
 *
 * Observe how the entry's text will match the string coming from the
 * @c "file,chosen" smart event:
 * @dontinclude fileselector_entry_example.c
 * @skip hook on the
 * @until }
 * Whenever you dismiss or acknowledges the file selector, after it's
 * raised, the @c event_info string will contain the last selection on
 * it (if any was made).
 *
 * Try, also, to type in a valid system path and, then, open the file
 * selector's window: it will start the file browsing there, for you.
 *
 * This is how the example, just after called, should look like:
 *
 * @image html screenshots/fileselector_entry_example_00.png
 * @image latex screenshots/fileselector_entry_example_00.eps width=\textwidth
 *
 * Click on the file selector entry to raise its internal file
 * selector, which will be contained on an <b>"inner window"</b>:
 *
 * @image html screenshots/fileselector_entry_example_01.png
 * @image latex screenshots/fileselector_entry_example_01.eps width=\textwidth
 *
 * Toggle the "inwin mode" switch off and, if you click on the file
 * selector entry again, you'll get @b two windows, the original one
 * (note the last selection there!)
 *
 * @image html screenshots/fileselector_entry_example_02.png
 * @image latex screenshots/fileselector_entry_example_02.eps width=\textwidth
 *
 * and the file selector's new one
 *
 * @image html screenshots/fileselector_entry_example_03.png
 * @image latex screenshots/fileselector_entry_example_03.eps width=\textwidth
 *
 * Play with the checkboxes to get the behavior changes on the file
 * selector entry. The respective API calls on the widget coming from
 * those knobs where shown in the code already.
 *
 * See the full @ref fileselector_entry_example_c "source code" for
 * this example.
 *
 */

/**
 * @page layout_example_01 Layout - Content, Table and Box
 *
 * This example shows how one can use the @ref Layout widget to create a
 * customized distribution of widgets on the screen, controlled by an Edje theme.
 * The full source code for this example can be found at @ref
 * layout_example_01_c.
 *
 * Our custom layout is defined by a file, @ref layout_example_edc, which is an
 * Edje theme file. Look for the Edje documentation to understand it. For now,
 * it's enough to know that we describe some specific parts on this layout
 * theme:
 * @li a title text field;
 * @li a box container;
 * @li a table container;
 * @li and a content container.
 *
 * Going straight to the code, the following snippet instantiates the layout
 * widget:
 *
 * @dontinclude layout_example_01.c
 * @skip elm_layout_add
 * @until evas_object_show(layout)
 *
 * As any other widget, we set some properties for the size calculation. But
 * notice on this piece of code the call to the function elm_layout_file_set().
 * Here is where the theme file is loaded, and particularly the specific group
 * from this theme file. Also notice that the theme file here is referenced as
 * an .edj, which is a .edc theme file compiled to its binary form. Again, look
 * for the Edje documentation for more information about theme files.
 *
 * Next, we fetch from our theme a data string referenced by the key "title".
 * This data was defined in the theme, and can be used as parameters which the
 * program get from the specific theme that it is using. In this case, we store
 * the title of this window and program in the theme, as a "data" entry, just
 * for demonstration purposes:
 *
 * @until }
 *
 * This call elm_layout_data_get() is used to fetch the string based on the key,
 * and elm_object_part_text_set() will set the part defined in the theme as
 * "example/title" to contain this string. This key "example/title" has nothing
 * special. It's just an arbitrary convention that we are using in this example.
 * Every string in this example referencing a part of this theme will be of the
 * form "example/<something>".
 *
 * Now let's start using our layout to distribute things on the window space.
 * Since the layout was added as a resize object to the elementary window, it
 * will always occupy the entire space available for this window.
 *
 * The theme already has a title, and it also defines a table element which is
 * positioned approximately between 50% and 70% of the height of this window,
 * and has 100% of the width. We create some widgets (two icons, a clock and a
 * button) and pack them inside the table, in a distribution similar to a HTML
 * table:
 *
 * @until evas_object_show(bt)
 *
 * Notice that we just set size hints for every object, and call the function
 * elm_layout_table_pack(), which does all the work. It will place the elements
 * in the specified row/column, with row and column span if required, and then
 * the object's size and position will be controlled by the layout widget. It
 * will also respect size hints, alignments and weight properties set to these
 * widgets. The resulting distribution on the screen depends on the table
 * properties (described in the theme), the size hints set on each widget, and
 * on the cells of the table that are being used.
 *
 * For instance, we add the two icons and the clock on the first, second and
 * third cells of the first row, and add the button the second row, making it
 * span for 3 columns (thus having the size of the entire table width). This
 * will result in a table that has 2 rows and 3 columns.
 *
 * Now let's add some widgets to the box area of our layout. This box is around
 * 20% and 50% of the vertical size of the layout, and 100% of its width. The
 * theme defines that it will use an "horizontal flow" distribution to its
 * elements. Unlike the table, a box will distribute elements without knowing
 * about rows and columns, and the distribution function selected will take care
 * of putting them in row, column, both, or any other available layout. This is
 * also described in the Edje documentation.
 *
 * This box area is similar to the @ref Box widget of elementary, with the
 * difference that its position and properties are controlled by the theme of the
 * layout. It also contains more than one API to add items to it, since the
 * items position now is defined in terms of a list of items, not a matrix.
 * There's the first position (can have items added to it with
 * elm_layout_box_prepend()), the last position (elm_layout_box_append()), the
 * nth position (elm_layout_box_insert_at()) and the position right before an
 * element (elm_layout_box_insert_before()). We use insert_at and prepend
 * functions to add the first two buttons to this box, and insert_before on the
 * callback of each button. The callback code will be shown later, but it
 * basically adds a button just before the clicked button using the
 * elm_layout_box_insert_before() function. Here's the code for adding the first
 * 2 buttons:
 *
 * @until evas_object_show(item)
 * @until evas_object_show(item)
 *
 * Finally, we have an area in this layout theme, in the bottom part of it,
 * reserved for adding an specific widget. Differently from the 2 parts
 * described until now, this one can only receive one widget with the call
 * elm_object_part_content_set() for the layout. If there was already an item on this specific part,
 * it will be deleted (one can use elm_object_part_content_unset() in order to remove
 * it without deleting). An example of removing it without deleting, but
 * manually deleting this widget just after that, can be seen on the callback
 * for this button. Actually, the callback defined for this button will clean
 * the two other parts (deleting all of their elements) and then remove and
 * delete this button.
 *
 * @until _swallow_btn_cb
 *
 * Also notice that, for this last added button, we don't have to call
 * evas_object_show() on it. This is a particularity of the theme for layouts,
 * that will have total control over the properties like size, position,
 * visibility and clipping of a widget added with elm_object_part_content_set().
 * Again, read the Edje documentation to understand this better.
 *
 * Now we just put the code for the different callbacks specified for each kind
 * of button and make simple comments about them:
 *
 * @dontinclude layout_example_01.c
 * @skip static void
 * @until evas_object_del(item)
 * @until }
 *
 * The first callback is used for the button in the table, and will just remove
 * itself from the table with elm_layout_table_unpack(), which remove items
 * without deleting them, and then calling evas_object_del() on itself.
 *
 * The second callback is for buttons added to the box. When clicked, these
 * buttons will create a new button, and add them to the same box, in the
 * position just before the clicked button.
 *
 * And the last callback is for the button added to the "content" area. It will
 * clear both the table and the box, passing @c EINA_TRUE to their respective @c
 * clear parameters, which will imply on the items of these containers being
 * deleted.
 *
 * A screenshot of this example can be seen on:
 *
 * @image html screenshots/layout_example_01.png
 * @image latex screenshots/layout_example_01.eps width=\textwidth
 *
 */

/**
 * @page layout_example_02 Layout - Predefined Layout
 *
 * This example shows how one can use the @ref Layout with a predefined theme
 * layout to add a back and next button to a simple window. The full source code
 * for this example can be found at @ref layout_example_02_c.
 *
 * After setting up the window and background, we add the layout widget to the
 * window. But instead of using elm_layout_file_set() to load its theme from a
 * custom theme file, we can use elm_layout_theme_set() to load one of the
 * predefined layouts that come with elementary. Particularly on this example,
 * we load the them of class "layout", group "application" and style
 * "content-back-next" (since we want the back and next buttons).
 *
 * @dontinclude layout_example_02.c
 * @skip elm_layout_add
 * @until evas_object_show(layout)
 *
 * This default theme contains only a "content" area named
 * "elm.swallow.content", where we can add any widget (it can be even a
 * container widget, like a box, frame, list, or even another layout). Since we
 * just want to show the resulting layout, we add a simple icon to it:
 *
 * @until layout_content_set
 *
 * This default layout also provides some signals when the next and prev buttons
 * are clicked. We can register callbacks to them with the
 * elm_object_signal_callback_add() function:
 *
 * @until elm,action,next
 *
 * In the @ref layout_example_03 you can see how to send signals to the layout with
 * elm_object_signal_emit().
 *
 * Now our callback just changes the picture being displayed when one of the
 * buttons are clicked:
 *
 * @dontinclude layout_example_02.c
 * @skip images
 * @until standard_set
 * @until }
 *
 * It's possible to see that it gets the name of the image being shown from the
 * array of image names, going forward on this array when "next" is clicked and
 * backward when "back" is clicked.
 *
 * A screenshot of this example can be seen on:
 *
 * @image html screenshots/layout_example_02.png
 * @image latex screenshots/layout_example_02.eps width=\textwidth
 */

/**
 * @page layout_example_03 Layout - Signals and Size Changed
 *
 * This example shows how one can send and receive signals to/from the layout,
 * and what to do when the layout theme has its size changed. The full source
 * code for this example can be found at @ref layout_example_03_c.
 *
 * In this exmaple we will use another group from the same layout theme file
 * used in @ref layout_example_01. Its instantiation and loading happens in the
 * following lines:
 *
 * @dontinclude layout_example_03.c
 * @skip elm_layout_add
 * @until evas_object_show
 *
 * This time we register a callback to be called whenever we receive a signal
 * after the end of the animation that happens in this layout:
 *
 * @until signal_callback_add
 *
 * We also add a button that will send signals to the layout:
 *
 * @until callback_add
 *
 * The callback for this button will check what type of signal it should send,
 * and then emit it. The code for this callback follows:
 *
 * @dontinclude layout_example_03.c
 * @skip static Eina_Bool
 * @until Enlarge
 * @until }
 * @until }
 *
 * As we said before, we are receiving a signal whenever the animation started
 * by the button click ends. This is the callback for that signal:
 *
 * @until }
 *
 * Notice from this callback that the elm_layout_sizing_eval() function must be
 * called if we want our widget to update its size after the layout theme having
 * changed its minimum size. This happens because the animation specified in the
 * theme increases the size of the content area to a value higher than the
 * widget size, thus requiring more space. But the elementary layout widget
 * has no way to know this, thus needing the elm_layout_sizing_eval() to
 * be called on the layout, informing that this size has changed.
 *
 * A screenshot of this example can be seen on:
 *
 * @image html screenshots/layout_example_03.png
 * @image latex screenshots/layout_example_03.eps width=\textwidth
 */

/**
 * @page tutorial_hover Hover example
 * @dontinclude hover_example_01.c
 *
 * On this example we are going to have a button that when clicked will show our
 * hover widget, this hover will have content set on it's left, top, right and
 * middle positions. In the middle position we are placing a button that when
 * clicked will hide the hover. We are also going to use a non-default theme
 * for our hover. We won't explain the functioning of button for that see @ref
 * Button.
 *
 * We start our example with a couple of callbacks that show and hide the data
 * they're given(which we'll see later on is the hover widget):
 * @skip static
 * @until }
 * @until }
 *
 * In our main function we'll do some initialization and then create 3
 * rectangles, one red, one green and one blue to use in our hover. We'll also
 * create the 2 buttons that will show and hide the hover:
 * @until show(bt2)
 *
 * With all of that squared away we can now get to the heart of the matter,
 * creating our hover widget, which is easy as pie:
 * @until hover
 *
 * Having created our hover we now need to set the parent and target. Which if
 * you recall from the function documentations are going to tell the hover which
 * area it should cover and where it should be centered:
 * @until bt
 *
 * Now we set the theme for our hover. We're using the popout theme which gives
 * our contents a white background and causes their appearance to be animated:
 * @until popout
 *
 * And finally we set the content for our positions:
 * @until bt2
 *
 * So far so good? Great 'cause that's all there is too it, what is left now is
 * just connecting our buttons to the callbacks we defined at the beginning of
 * the example and run the main loop:
 * @until ELM_MAIN
 *
 * Our example will initially look like this:
 *
 * @image html screenshots/hover_example_01.png
 * @image latex screenshots/hover_example_01.eps width=\textwidth
 *
 * And after you click the "Show hover" button it will look like this:
 *
 * @image html screenshots/hover_example_01_a.png
 * @image latex screenshots/hover_example_01_a.eps width=\textwidth
 *
 * @example hover_example_01.c
 */

/**
  * @page tutorial_flip Flip example
  * @dontinclude flip_example_01.c
  *
  * This example will show a flip with two rectangles on it(one blue, one
  * green). Our example will allow the user to choose the animation the flip
  * uses and to interact with it. To allow the user to choose the interaction
  * mode we use radio buttons, we will however not explain them, if you would
  * like to know more about radio buttons see @ref Radio.
  *
  * We start our example with the usual setup and then create the 2 rectangles
  * we will use in our flip:
  * @until show(rect2)
  *
  * The next thing to do is to create our flip and set it's front and back
  * content:
  * @until show
  *
  * The next thing we do is set the interaction mode(which the user can later
  * change) to the page animation:
  * @until PAGE
  *
  * Setting a interaction mode however is not sufficient, we also need to
  * choose which directions we allow interaction from, for this example we
  * will use all of them:
  * @until RIGHT
  *
  * We are also going to set the hintsize to the entire flip(in all directions)
  * to make our flip very easy to interact with:
  * @until RIGHT
  *
  * After that we create our radio buttons and start the main loop:
  * @until ELM_MAIN()
  *
  * When the user clicks a radio button a function that changes the
  * interaction mode and animates the flip is called:
  * @until }
  * @note The elm_flip_go() call here serves no purpose other than to
  * illustrate that it's possible to animate the flip programmatically.
  *
  * Our example will look like this:
  *
  * @image html screenshots/flip_example_01.png
  * @image latex screenshots/flip_example_01.eps width=\textwidth
  *
  * @note Since this is an animated example the screenshot doesn't do it
  * justice, it is a good idea to compile it and see the animations.
  *
  * @example flip_example_01.c
  */

 /**
  * @page tutorial_label Label example
  * @dontinclude label_example_01.c
  *
  * In this example we are going to create 6 labels, set some properties on
  * them and see what changes in appearance those properties cause.
  *
  * We start with the setup code that by now you should be familiar with:
  * @until elm_win_autodel_set
  *
  * For our first label we have a moderately long text(that doesn't fit in the
  * label's width) so we will make it a sliding label. Since the text isn't
  * too long we don't need the animation to be very long, 3 seconds should
  * give us a nice speed:
  * @until show(label
  *
  * For our second label we have the same text, but this time we aren't going
  * to have it slide, we're going to ellipsize it. Because we ask our label
  * widget to ellipsize the text it will first diminsh the fontsize so that it
  * can show as much of the text as possible:
  * @until show(label
  *
  * For the third label we are going to ellipsize the text again, however this
  * time to make sure the fontsize isn't diminshed we will set a line wrap.
  * The wrap won't actually cause a line break because we set the label to
  * ellipsize:
  * @until show(label
  *
  * For our fourth label we will set line wrapping but won't set ellipsis, so
  * that our text will indeed be wrapped instead of ellipsized. For this label
  * we choose character wrap:
  * @until show(label
  *
  * Just two more, for our fifth label we do the same as for the fourth
  * except we set the wrap to word:
  * @until show(label
  *
  * And last but not least for our sixth label we set the style to "marker" and
  * the color to red (the default color is white which would be hard to see on
  * our white background):
  * @until show(label
  *
  * Our example will look like this:
  *
  * @image html screenshots/label_example_01.png
  * @image latex screenshots/label_example_01.eps width=\textwidth
  *
  * @example label_example_01.c
  */

 /**
  * @page tutorial_image Image example
  * @dontinclude image_example_01.c
  *
  * This example is as simple as possible. An image object will be added to the
  * window over a white background, and set to be resizable together with the
  * window. All the options set through the example will affect the behavior of
  * this image.
  *
  * We start with the code for creating a window and its background, and also
  * add the code to write the path to the image that will be loaded:
  *
  * @skip int
  * @until snprintf
  *
  * Now we create the image object, and set that file to be loaded:
  *
  * @until }
  *
  * We can now go setting our options.
  *
  * elm_image_no_scale_set() is used just to set this value to true (we
  * don't want to scale our image anyway, just resize it).
  *
  * elm_image_resizable_set() is used to allow the image to be resized to a size
  * smaller than the original one, but not to a size bigger than it.
  *
  * elm_image_smooth_set() will disable the smooth scaling, so the scale
  * algorithm used to scale the image to the new object size is going to be
  * faster, but with a lower quality.
  *
  * elm_image_orient_set() is used to flip the image around the (1, 0) (0, 1)
  * diagonal.
  *
  * elm_image_aspect_fixed_set() is used to keep the original aspect
  * ratio of the image, even when the window is resized to another aspect ratio.
  *
  * elm_image_fill_outside_set() is used to ensure that the image will fill the
  * entire area available to it, even if keeping the aspect ratio. The image
  * will overflow its width or height (any of them that is necessary) to the
  * object area, instead of resizing the image down until it can fit entirely in
  * this area.
  *
  * elm_image_editable_set() is used just to cover the API, but won't affect
  * this example since we are not using any copy & paste property.
  *
  * This is the code for setting these options:
  *
  * @until editable
  *
  * Now some last touches in our object size hints, window and background, to
  * display this image properly:
  *
  * @until ELM_MAIN
  *
  * This example will look like this:
  *
  * @image html screenshots/image_example_01.png
  * @image latex screenshots/image_example_01.eps width=\textwidth
  *
  * @example image_example_01.c
  */

 /**
  * @page tutorial_icon Icon example
  * @dontinclude icon_example_01.c
  *
  * This example is as simple as possible. An icon object will be added to the
  * window over a white background, and set to be resizable together with the
  * window. All the options set through the example will affect the behavior of
  * this icon.
  *
  * We start with the code for creating a window:
  *
  * @skip int
  * @until elm_win_autodel_set
  *
  * Now we create the icon object, and set lookup order of the icon, and choose
  * the "home" icon:
  *
  * @until elm_icon_standard_set
  *
  * An interesting thing is that after setting this, it's possible to check where
  * in the filesystem is the theme used by this icon, and the name of the group
  * used:
  *
  * @until printf
  *
  * We can now go setting our options.
  *
  * elm_image_no_scale_set() is used just to set this value to true (we
  * don't want to scale our icon anyway, just resize it).
  *
  * elm_image_resizable_set() is used to allow the icon to be resized to a size
  * smaller than the original one, but not to a size bigger than it.
  *
  * elm_image_smooth_set() will disable the smooth scaling, so the scale
  * algorithm used to scale the icon to the new object size is going to be
  * faster, but with a lower quality.
  *
  * elm_image_fill_outside_set() is used to ensure that the icon will fill the
  * entire area available to it, even if keeping the aspect ratio. The icon
  * will overflow its width or height (any of them that is necessary) to the
  * object area, instead of resizing the icon down until it can fit entirely in
  * this area.
  *
  * This is the code for setting these options:
  *
  * @until fill_outside
  *
  * However, if you try this example you may notice that this image is not being
  * affected by all of these options. This happens because the used icon will be
  * from elementary theme, and thus it has its own set of options like smooth
  * scaling and fill_outside options. You can change the "home" icon to use some
  * image (from your system) and see that then those options will be respected.
  *
  * Now some last touches in our object size hints, window and background, to
  * display this icon properly:
  *
  * @until ELM_MAIN
  *
  * This example will look like this:
  *
  * @image html screenshots/icon_example_01.png
  * @image latex screenshots/icon_example_01.eps width=\textwidth
  *
  * @example icon_example_01.c
  */

/**
 * @page tutorial_hoversel Hoversel example
 * @dontinclude hoversel_example_01.c
 *
 * In this example we will create a hoversel with 3 items, one with a label but
 * no icon and two with both a label and an icon. Every item that is clicked
 * will be deleted, but everytime the hoversel is activated we will also add an
 * item. In addition our first item will print all items when clicked and our
 * third item will clear all items in the hoversel.
 *
 * We will start with the normal creation of window stuff:
 * @until show(bg)
 *
 * Next we will create a red rectangle to use as the icon of our hoversel:
 * @until show
 *
 * And now we create our hoversel and set some of it's properties. We set @p win
 * as its parent, ask it to not be horizontal(be vertical) and give it a label
 * and icon:
 * @until "icon", rect)
 *
 * Next we will add our three items, setting a callback to be called for the
 * first and third:
 * @until _rm_items
 *
 * We also set a pair of callbacks to be called whenever any item is selected or
 * when the hoversel is activated:
 * @until clicked
 *
 * And then ask that our hoversel be shown and run the main loop:
 * @until ELM_MAIN
 *
 * We now have the callback for our first item which prints all items in the
 * hoversel:
 * @until }
 *
 * Next we have the callback for our third item which removes all items from the
 * hoversel:
 * @until }
 *
 * Next we have the callback that is called whenever an item is clicked and
 * deletes that item:
 * @until }
 *
 * And the callback that is called when the hoversel is activated and adds an
 * item to the hoversel. Note that since we allocate memory for the item we need
 * to know when the item dies so we can free that memory:
 * @until }
 *
 * And finally the callback that frees the memory we allocated for items created
 * in the @p _add_item callback:
 * @until }
 *
 * Our example will initially look like this:
 *
 * @image html screenshots/hoversel_example_01.png
 * @image latex screenshots/hoversel_example_01.eps width=\textwidth
 *
 * And when the hoversel is clicked it will look like this:
 *
 * @image html screenshots/hoversel_example_01_a.png
 * @image latex screenshots/hoversel_example_01_a.eps width=\textwidth
 *
 * @example hoversel_example_01.c
 */

/**
 * @page conformant_example Conformant Example.
 *
 * In this example we'll explain how to create applications to work
 * with illume, considering space required for virtual keyboards, indicator
 * and softkeys.
 *
 * Illume is a module for Enlightenment that modifies the user interface
 * to work cleanly and nicely on a mobile device. It has support for
 * virtual keyboard, among other nice features.
 *
 * Let's start creating a very simple window with a vertical box
 * with multi-line entry between two buttons.
 * This entry will expand filling all space on window not used by buttons.
 *
 * @dontinclude conformant_example_01.c
 * @skipline elm_main
 * @until }
 *
 * For information about how to create windows, boxes, buttons or entries,
 * look for documentation for these widgets.
 *
 * It will looks fine when you don't need a virtual keyboard, as you
 * can see on the following image:
 *
 * @image html screenshots/conformant_example_01.png
 * @image latex screenshots/conformant_example_01.eps width=\textwidth
 *
 * But if you call a virtual keyboard, the window will resize, changing
 * widgets size and position. All the content will shrink.
 *
 * If you don't want such behaviour, you
 * will need a conformant to account for space taken up by the indicator,
 * virtual keyboard and softkey.
 *
 * In this case, using the conformant in a proper way, you will have
 * a window like the following:
 *
 * @image html screenshots/conformant_example_02.png
 * @image latex screenshots/conformant_example_02.eps width=\textwidth
 *
 * As you can see, it guess the space that will be required by the keyboard,
 * indicator and softkey bars.
 *
 * So, let's study each step required to transform our initial example on
 * the second one.
 *
 * First of all, we need to set the window as an illume conformant window:
 * @dontinclude conformant_example_02.c
 * @skipline elm_win_conformant_set
 *
 * Next, we'll add a conformant widget, and set it to resize with the window,
 * instead of the box.
 * @skipline conform
 * @until evas_object_show
 *
 * Finally, we'll set the box as conformant's content, just like this:
 * @skipline elm_object_content_set
 *
 * Compare both examples code:
 * @ref conformant_example_01.c "conformant_example_01.c"
 * @ref conformant_example_02.c "conformant_example_02.c"
 *
 * @example conformant_example_01.c
 * @example conformant_example_02.c
 */

/**
 * @page index_example_01 Index widget example 1
 *
 * This code places an Elementary index widget on a window, which also
 * has a very long list of arbitrary strings on it.  The list is
 * sorted alphabetically and the index will be used to index the first
 * items of each set of strings beginning with an alphabet letter.
 *
 * Below the list are some buttons, which are there just to exercise
 * some index widget's API.
 *
 * Here's how we instantiate it:
 * @dontinclude index_example_01.c
 * @skip elm_list_add
 * @until evas_object_show(d.index)
 * where we're showing also the list being created. Note that we issue
 * elm_win_resize_object_add() on the index, so that it's set to have
 * the whole window as its container. Then, we have to populate both
 * list and index widgets:
 * @dontinclude index_example_01.c
 * @skip for (i = 0; i < (sizeof(dict) / sizeof(dict[0])); i++)
 * @until }
 * @until }
 *
 * The strings populating the list come from a file
 * @dontinclude index_example_01.c
 * @skip static const char *dict
 * @until }
 *
 * We use the @c curr char variable to hold the last initial letter
 * seen on that ordered list of strings, so that we're able to have an
 * index item pointing to each list item starting a new letter
 * "section". Note that our index item data pointers will be the list
 * item handles. We are also setting a callback function to index
 * items deletion events:
 * @dontinclude index_example_01.c
 * @skip static void
 * @until }
 *
 * There, we show you that the @c event_info pointer will contain the
 * item in question's data, i.e., a given list item's pointer. Because
 * item data is also returned in the @c data argument on
 * @c Evas_Smart_Cb functions, those two pointers must have the same
 * values. On this deletion callback, we're deleting the referred list
 * item too, just to exemplify that anything could be done there.
 *
 * Next, we hook to two smart events of the index object:
 * @dontinclude index_example_01.c
 * @skip smart_callback_add(d.index
 * @until _index_selected
 * @dontinclude index_example_01.c
 * @skip "delay,changed" hook
 * @until }
 * @until }
 *
 * Check that, whenever one holds the mouse pressed over a given index
 * letter for some time, the list beneath it will roll down to the
 * item pointed to by that index item. When one releases the mouse
 * button, the second callback takes place. There, we check that the
 * reported item data, on @c event_info, is the same reported by
 * elm_index_selected_item_get(), which gives the last selection's
 * data on the index widget.
 *
 * The first of the three buttons that follow will call
 * elm_index_autohide_disabled_set(), thus showing the index automatically for
 * you, if it's not already visible, what is checked with
 * elm_index_autohide_disabled_get(). The second button will exercise @b deletion
 * of index item objects, by the following code:
 * @dontinclude index_example_01.c
 * @skip delete an index item
 * @until }
 *
 * It will get the last index item selected's data and find the
 * respective index item handle(#Elm_Object_Item) with elm_index_item_find().
 * We need the latter to query the indexing letter string from, with
 * elm_index_item_letter_get(). Next, comes the delition, itself,
 * which will also trigger the @c _index_item_del callback function,
 * as said above.
 *
 * The third button, finally, will exercise elm_index_item_clear(),
 * which will delete @b all of the index's items.
 *
 * This is how the example program's window looks like with the index
 * widget hidden:
 * @image html screenshots/index_example_00.png
 * @image latex screenshots/index_example_00.eps
 *
 * When it's shown, it's like the following figure:
 * @image html screenshots/index_example_01.png
 * @image latex screenshots/index_example_01.eps
 *
 * See the full @ref index_example_01_c "source code" for
 * this example.
 *
 */

/**
 * @page index_example_02 Index widget example 2
 *
 * This code places an Elementary index widget on a window, indexing
 * grid items. The items are placed so that their labels @b don't
 * follow any order, but the index itself is ordered (through
 * elm_index_item_sorted_insert()). This is a complement to to @ref
 * index_example_01 "the first example on indexes".
 *
 * Here's the list of item labels to be used on the grid (in that
 * order):
 * @dontinclude index_example_02.c
 * @skip static const char *items
 * @until };
 *
 * In the interesting part of the code, here, we first instantiate the
 * grid (more on grids on their examples) and, after creating our
 * index, for each grid item we also create an index one to reference
 * it:
 * @dontinclude index_example_02.c
 * @skip grid = elm_gengrid_add
 * @until }
 * @until smart_callback_add
 *
 * The order in which they'll appear in the index, though, is @b
 * alphabetical, becase of elm_index_item_sorted_insert() usage
 * together with the comparing function, where we take the letters of
 * each index item to base our ordering on. The parameters on
 * @c _index_cmp have to be declared as void pointers because of the
 * @c Eina_Compare_Cb prototype requisition, but in this case we know
 * they'll be index item(#Elm_Object_Item)'s:
 * @dontinclude index_example_02.c
 * @skip ordering alphabetically
 * @until }
 *
 * The last interesting bit is the callback in the @c "delay,changed"
 * smart event, which will bring the given grid item to the grid's
 * visible area:
 * @dontinclude index_example_02.c
 * @skip static void
 * @until }
 *
 * Note how the grid will move kind of randomly while you move your
 * mouse pointer held over the index from top to bottom -- that's
 * because of the the random order the items have in the grid itself.
 *
 * This is how the example program's window looks like:
 * @image html screenshots/index_example_03.png
 * @image latex screenshots/index_example_03.eps
 *
 * See the full @ref index_example_02.c "source code" for
 * this example.
 *
 */

/**
 * @page tutorial_ctxpopup Ctxpopup example
 * @dontinclude ctxpopup_example_01.c
 *
 * In this example we have a list with two items, when either item is clicked
 * a ctxpopup for it will be shown. Our two ctxpopups are quite different, the
 * one for the first item is a vertical and it's items contain both labels and
 * icons, the one for the second item is horizontal and it's items have icons
 * but not labels.
 *
 * We will begin examining our example code by looking at the callback we'll use
 * when items in the ctxpopup are clicked. It's very simple, all it does is
 * print the label present in the ctxpopup item:
 * @until }
 *
 * Next we examine a function that creates ctxpopup items, it was created to
 * avoid repeating the same code whenever we needed to add an item to our
 * ctxpopup. Our function creates an icon from the standard set of icons, and
 * then creates the item, with the label received as an argument. We also set
 * the callback to be called when the item is clicked:
 * @until }
 *
 * Finally we have the function that will create the ctxpopup for the first item
 * in our list. This one is somewhat more complex though, so let's go through it
 * in parts. First we declare our variable and add the ctxpopup:
 * @until ctxpopup_add
 *
 * Next we create a bunch of items for our ctxpopup, marking two of them as
 * disabled just so we can see what that will look like:
 * @until disabled_set
 * @until disabled_set
 *
 * Then we ask evas where the mouse pointer was so that we can have our ctxpopup
 * appear in the right place, set a maximum size for the ctxpopup, move it and
 * show it:
 * @until show
 *
 * And last we mark the list item as not selected:
 * @until }
 *
 * Our next function is the callback that will create the ctxpopup for the
 * second list item, it is very similar to the previous function. A couple of
 * interesting things to note is that we ask our ctxpopup to be horizontal, and
 * that we pass NULL as the label for every item:
 * @until }
 *
 * And with all of that in place we can now get to our main function where we
 * create the window, the list, the list items and run the main loop:
 * @until ELM_MAIN()
 *
 * The example will initially look like this:
 *
 * @image html screenshots/ctxpopup_example_01.png
 * @image latex screenshots/ctxpopup_example_01.eps width=\textwidth
 *
 * @note This doesn't show the ctxpopup tough, since it will only appear when
 * we click one of the list items.
 *
 * Here is what our first ctxpopup will look like:
 *
 * @image html screenshots/ctxpopup_example_01_a.png
 * @image latex screenshots/ctxpopup_example_01_a.eps width=\textwidth
 *
 * And here the second ctxpopup:
 *
 * @image html screenshots/ctxpopup_example_01_b.png
 * @image latex screenshots/ctxpopup_example_01_b.eps width=\textwidth
 *
 * @example ctxpopup_example_01.c
 */

/**
 * @page tutorial_separator Separator example
 * @dontinclude separator_example_01.c
 *
 * In this example we are going to pack two rectangles in a box, and have a
 * separator in the middle.
 *
 * So we start we the window, background, box and rectangle creation, all pretty
 * normal stuff:
 * @until pack_end
 *
 * Once we have our first rectangle in the box we create and add our separator:
 * @until pack_end
 * @note Since our box is in horizontal mode it's a good idea to set the
 * separator to be horizontal too.
 *
 * And now we add our second rectangle and run the main loop:
 * @until ELM_MAIN
 *
 * This example will look like this:
 *
 * @image html screenshots/separator_example_01.png
 * @image latex screenshots/separator_example_01.eps width=\textwidth
 *
 * @example separator_example_01.c
 */

/**
 * @page tutorial_radio Radio example
 * @dontinclude radio_example_01.c
 *
 * In this example we will create 4 radio buttons, three of them in a group and
 * another one not in the group. We will also have the radios in the group
 * change the value of a variable directly and have then print it when the value
 * changes. The fourth button is in the example just to make clear that radios
 * outside the group don't affect the group.
 *
 * We'll start with the usual includes:
 * @skipline #include
 *
 * And move right to declaring a static variable(the one whose value the radios
 * will change):
 * @until static
 *
 * We now need to have a window and all that good stuff to be able to place our
 * radios in:
 * @until show(bx)
 *
 * And now we create a radio button, since this is the first button in our group
 * we set the group to be the radio(so we can set the other radios in the same
 * group). We also set the state value of this radio to 1 and the value pointer
 * to @p val, since val is @p 1 this has the additional effect of setting the
 * radio value to @p 1. For this radio we choose the default home icon:
 * @until show
 *
 * To check that our radio buttons are working we'll add a callback to the
 * "changed" signal of the radio:
 * @until smart_callback
 *
 * The creation of our second radio button is almost identical, the 2
 * differences worth noting are, the value of this radio 2 and that we add this
 * radio to the group of the first radio:
 * @until smart_callback
 *
 * For our third callback we'll omit the icon and set the value to 3, we'll also
 * add it to the group of the first radio:
 * @until smart_callback
 *
 * Our fourth callback has a value of 4, no icon and most relevantly is not a
 * member of the same group as the other radios:
 * @until show
 *
 * We finally run the main loop:
 * @until ELM_MAIN
 *
 * And the last detail in our example is the callback that prints @p val so that
 * we can see that the radios are indeed changing its value:
 * @until }
 *
 * The example will look like this:
 *
 * @image html screenshots/radio_example_01.png
 * @image latex screenshots/radio_example_01.eps width=\textwidth
 *
 * @example radio_example_01.c
 */

/**
 * @page tutorial_panel Panel example
 * @dontinclude panel_example_01.c
 *
 * In this example will have 3 panels, one for each possible orientation. Two of
 * our panels will start out hidden, the third will start out expanded. For each
 * of the panels we will use a label as the content, it's however possible to
 * have any widget(including containers) as the content of panels.
 *
 * We start by doing some setup, code you should be familiar with from other
 * examples:
 * @until show(bx)
 *
 * And move right to creating our first panel, for this panel we are going to
 * choose the orientation as TOP and toggle it(tell it to hide itself):
 * @until pack_end
 *
 * For the second panel we choose the RIGHT orientation and explicitly set the
 * state as hidden:
 * @until pack_end
 *
 * For our third and last panel we won't set the orientation(which means it will
 * use the default: LEFT):
 * @until pack_end
 *
 * All that is left is running the main loop:
 * @until ELM_MAIN
 *
 * This example will look like this;
 *
 * @image html screenshots/panel_example_01.png
 * @image latex screenshots/panel_example_01.eps width=\textwidth
 * @note The buttons with arrow allow the user to hide/show the panels.
 *
 * @example panel_example_01.c
 */

/**
 * @page gengrid_example Gengrid widget example
 *
 * This application is a thorough exercise on the gengrid widget's
 * API. We place an Elementary gengrid widget on a window, with
 * various knobs below its viewport, each one acting on it somehow.
 *
 * The code's relevant part begins at the grid's creation. After
 * instantiating it, we set its items sizes, so that we don't end with
 * items one finger size wide, only. We're setting them to fat, 150
 * pixel wide ones, for this example. We give it some size hints, not
 * to be discussed in this context and, than, we register a callback
 * on one of its smart events -- the one coming each time an item gets
 * doubly clicked. There, we just print the item handle's value.
 * @dontinclude gengrid_example.c
 * @skip grid = elm_gengrid_add
 * @until evas_object_sho
 * @dontinclude gengrid_example.c
 * @skip item double click callback
 * @until }
 *
 * Before we actually start to deal with the items API, let's show
 * some things items will be using throughout all the code. The first
 * of them is a struct to be used as item data, for all of them:
 * @dontinclude gengrid_example.c
 * @skip typedef struct
 * @until Item;
 *
 * That path will be used to index an image, to be swallowed into one
 * of the item's icon spots. The images themselves are distributed
 * with Elementary:
 * @dontinclude gengrid_example.c
 * @skip static const char *imgs
 * @until ;
 *
 * We also have an (unique) gengrid item class we'll be using for
 * items in the example:
 * @dontinclude gengrid_example.c
 * @skip static Elm_Gengrid_Item_Class
 * @until static Elm_Gengrid_Item_Class
 * @dontinclude gengrid_example.c
 * @skip item_style =
 * @until _grid_del
 *
 * As you see, our items will follow the default theme on gengrid
 * items. For the label fetching code, we return a string composed of
 * the item's image path:
 * @dontinclude gengrid_example.c
 * @skip label fetching callback
 * @until }
 *
 * For item icons, we'll be populating the item default theme's two
 * icon spots, @c "elm.swallow.icon" and @c "elm.swallow.end". The
 * former will receive one of the images in our list (in the form of
 * a @ref bg_02_example_page "background"), while the latter will be
 * a check widget. Note that we prevent the check to propagate click
 * events, so that the user can toggle its state without messing with
 * the respective item's selection in the grid:
 * @dontinclude gengrid_example.c
 * @skip icon fetching callback
 * @until return NULL
 * @until }
 *
 * As the default gengrid item's theme does not have parts
 * implementing item states, we'll be just returning false for every
 * item state:
 * @dontinclude gengrid_example.c
 * @skip state fetching callback
 * @until }
 *
 * Finally, the deletion callback on gengrid items takes care of
 * freeing the item's label string and its data struct:
 * @dontinclude gengrid_example.c
 * @skip deletion callback
 * @until }
 *
 * Let's move to item insertion/deletion knobs, them. They are four
 * buttons, above the grid's viewport, namely
 * - "Append" (to append an item to the grid),
 * - "Prepend" (to prepend an item to the grid),
 * - "Insert before" (to insert an item before the selection, on the
 *   grid),
 * - "Insert after" (to insert an item after the selection, on the
 *   grid),
 * - "Clear" (to delete all items in the grid),
 * - "Bring in 1st" (to make the 1st item visible, by scrolling),
 * - "Show last" (to directly show the last item),
 * .
 * which are displaced and declared in that order. We're not dealing
 * with the buttons' creation code (see @ref button_example_01
 * "a button example", for more details on it), but with their @c
 * "clicked" registered callbacks.  For all of them, the grid's handle
 * is passed as @c data. The ones creating new items use a common
 * code, which just gives a new @c Example_Item struct, with @c path
 * filled with a random image in our images list:
 * @dontinclude gengrid_example.c
 * @skip new item with random path
 * @until }
 *
 * Moreover, that ones will set a common function to be issued on the
 * selection of the items. There, we print the item handle's value,
 * along with the callback function data. The latter will be @c NULL,
 * always, because it's what we pass when adding all icons. By using
 * elm_object_item_data_get(), we can have the item data back and,
 * with that, we're priting the item's path string. Finally, we
 * exemplify elm_gengrid_item_pos_get(), printing the item's position
 * in the grid:
 * @dontinclude gengrid_example.c
 * @skip item selection callback
 * @until }
 *
 * The appending button will exercise elm_gengrid_item_append(), simply:
 * @dontinclude gengrid_example.c
 * @skip append an item
 * @until }
 *
 * The prepending, naturally, is analogous, but exercising
 * elm_gengrid_item_prepend(), on its turn. The "Insert before" one
 * will expect an item to be selected in the grid, so that it will
 * insert a new item just before it:
 * @dontinclude gengrid_example.c
 * @skip "insert before" callback
 * @until }
 *
 * The "Insert after" is analogous, just using
 * elm_gengrid_item_insert_after(), instead. The "Clear" button will,
 * as expected, just issue elm_gengrid_clear():
 * @dontinclude gengrid_example.c
 * @skip delete items
 * @until }
 *
 * The "Bring in 1st" button is there exercise two gengrid functions
 * -- elm_gengrid_first_item_get() and elm_gengrid_item_bring_in().
 * With the former, we get a handle to the first item and, with the
 * latter, you'll see that the widget animatedly scrolls its view
 * until we can see that item:
 * @dontinclude gengrid_example.c
 * @skip bring in 1st item
 * @until }
 *
 * The "Show last", in its turn, will use elm_gengrid_last_item_get()
 * and elm_gengrid_item_show(). The latter differs from
 * elm_gengrid_item_bring_in() in that it immediately replaces the
 * contents of the grid's viewport with the region containing the item
 * in question:
 * @dontinclude gengrid_example.c
 * @skip show last item
 * @until }
 *
 * To change the grid's cell (items) size, we've placed a spinner,
 * which has the following @c "changed" smart callback:
 * @dontinclude gengrid_example.c
 * @skip change items' size
 * @until }
 *
 * Experiment with it and see how the items are affected. The "Disable
 * item" button will, as the name says, disable the currently selected
 * item:
 * @dontinclude gengrid_example.c
 * @skip disable selected item
 * @until }
 * Note that we also make use of elm_gengrid_item_selected_set(),
 * there, thus making the item unselected before we actually disable
 * it.
 *
 * To toggle between horizontal and vertical layouting modes on the
 * grid, use the "Horizontal mode" check, which will call the
 * respective API function on the grid:
 * @dontinclude gengrid_example.c
 * @skip change layouting mode
 * @until }
 *
 * If you toggle the check right after that one, "Always select",
 * you'll notice all subsequent clicks on the @b same grid item will
 * still issue the selection callback on it, what is different from
 * when it's not checked. This is the
 * elm_gengrid_select_mode_set() behavior:
 * @dontinclude gengrid_example.c
 * @skip "always select" callback
 * @until }
 *
 * One more check follows, "Bouncing", which will turn on/off the
 * bouncing animations on the grid, when one scrolls past its
 * borders. Experiment with scrolling the grid to get the idea, having
 * it turned on and off:
 * @dontinclude gengrid_example.c
 * @skip "bouncing mode" callback
 * @until }
 *
 * The next two checks will affect items selection on the grid. The
 * first, "Multi-selection", will make it possible to select more the
 * one item on the grid. Because it wouldn't make sense to fetch for
 * an unique selected item on this case, we also disable two of the
 * buttons, which insert items relatively, if multi-selection is on:
 * @dontinclude gengrid_example.c
 * @skip multi-selection callback
 * @until }
 *
 * Note that we also @b unselect all items in the grid, when returning
 * from multi-selection mode, making use of
 * elm_gengrid_item_selected_set().
 *
 * The second check acting on selection, "No selection", is just what
 * its name depicts -- no selection will be allowed anymore, on the
 * grid, while it's on. Check it out for yourself, interacting with
 * the program:
 * @dontinclude gengrid_example.c
 * @skip no selection callback
 * @until }
 *
 * We have, finally, one more line of knobs, now sliders, to change
 * the grids behavior. The two first will change the horizontal @b
 * alignment of the whole actual grid of items within the gengrid's
 * viewport:
 * @dontinclude gengrid_example.c
 * @skip items grid horizontal alignment change
 * @until }
 *
 * Naturally, the vertical counterpart just issues
 * elm_gengrid_align_set() changing the second alignment component,
 * instead.
 *
 * The last slider will change the grid's <b>page size</b>, relative
 * to its own one. Try to change those values and, one manner of
 * observing the paging behavior, is to scroll softly and release the
 * mouse button, with different page sizes, at different grid
 * positions, while having lots of items in it -- you'll see it
 * snapping to page boundaries differenty, for each configuration:
 * @dontinclude gengrid_example.c
 * @skip page relative size change
 * @until }
 *
 * This is how the example program's window looks like:
 * @image html screenshots/gengrid_example.png
 * @image latex screenshots/gengrid_example.eps width=\textwidth
 *
 * Note that it starts with three items which we included at will:
 * @dontinclude gengrid_example.c
 * @skip _clicked(grid,
 * @until _clicked(grid,
 * @until _clicked(grid,
 * @until _clicked(grid,
 *
 * See the full @ref gengrid_example_c "source code" for
 * this example.
 *
 */
/**
 * @page entry_example Entry - Example of simple editing
 *
 * As a general overview of @ref Entry we are going to write an, albeit simple,
 * functional editor. Although intended to show how elm_entry works, this
 * example also makes extensive use of several other widgets. The full code
 * can be found in @ref entry_example.c "entry_example.c" and in the following
 * lines we'll go through the parts especific to the @ref Entry widget.
 *
 * The program itself is a simple editor, with a file already set to it, that
 * can be set to autosave or not and allows insertion of emoticons and some
 * formatted text. As of this writing, the capabilities of format edition in
 * the entry are very limited, so a lot of manual work is required to change
 * the current text.
 *
 * In any case, the program allows some changes by using the buttons on the
 * top of the window and returning focus back to the main entry afterwards.
 *
 * @image html screenshots/entry_example.png
 * @image latex screenshots/entry_example.eps width=\textwidth
 *
 * We'll begin by showing a few structures used throught the program. First,
 * the application owns data that holds the main window and the main entry
 * where the editting happens. Then, an auxiliar structure we'll use later
 * when inserting icons in our text.
 * @dontinclude entry_example.c
 * @skip typedef
 * @until App_Inwin_Data
 *
 * A little convenience function will insert whatever text we need in the
 * buffer at the current cursor's position and set focus back to this entry.
 * This is done mostly because clicking on any button will make them steal
 * focus, which makes writing text more cumbersome.
 * @skip static void
 * @until }
 *
 * One of the buttons on the top will trigger an @ref Inwin to open and show
 * us several icons we can insert into the text. We'll jump over most of these
 * functions, but when all the options are chosen, we insert the special
 * markup text that will show the chosen icon in place.
 * @skip edje_file_collection_list_free(emos)
 * @skip static void
 * @until evas_object_del
 * @until }
 *
 * As can be seen in that function, the program lets us add icons to our entry
 * using all the possible configurations for them. That should help to
 * clarify how the different combinations work out by actually seeing them
 * in action.
 *
 * The same popup window has a page to set the settings of the chosen icon,
 * that is, the size and how the item will be placed within the line.
 *
 * The size is done with two entries, limitted to accept numbers and a fixed
 * size of characters. Changing the value in this entries will update the icon
 * size in our struct as seen in the next two callbacks.
 * @skip static void
 * @until }
 * @until }
 *
 * The rest of the options are handled with radio buttons, since only one type
 * of size can be used (@c size, @c absize or @c relsize) and for the vertical
 * sizing it needs to choose between @c ascent and @c full. Depending on which
 * is chosen, the @c item tag is formed accordingly as seen before.
 * @skip static Evas_Object
 * @until evas_object_show(rvascent)
 *
 * The first of our entries is here. There's something worth mentioning about
 * the way we'll create this one. Normally, any entry regardless of whether is
 * single line or not, will be set to scrollable, but in this case, since we
 * are limitting how many characters can fit in them and we know we don't need
 * scrolling, we are not setting this flag. This makes the entry have virtually
 * no appearance on screen, other than its text. This is because an entry is
 * just that, a box that holds text, and in order to have some frame around it
 * or a background color, another widget needs to provide this. When an entry
 * is scrollable, the same scroller used internally does this.
 * We are using @ref Frame "frames" here to provide some decoration around,
 * then creating our entries, set them to single line, add our two filters and
 * the callback for when their value change.
 * @until _height_changed_cb
 *
 * This function ends with the button that will finally call the item
 * into our editting string.
 * @until }
 *
 * Then we get to the format edition. Here we can add the @c bold and
 * @c emphasis tags to parts of our text. There's a lot of manual work to
 * know what to do here, since we are not implementing an entire state manager
 * and the entry itself doesn't, yet, support all the needed capabilities to
 * make this simpler. We begin by getting the format we are using in our
 * function from the button pressed.
 * @skip  _format_change_cb(void *data, Evas_Object *obj, void *event EINA_UNUSED))
 * @until sizeof(fmt_close)
 *
 * Next we need to find out if we need to insert an opening or a closing tag.
 * For this, we store the current cursor position and create a selection
 * from this point until the beginning of our text, and then get the selected
 * text to look for any existing format tags in it. This is currently the only
 * way in which we can find out what formats is being used in the entry.
 * @until }
 * @until }
 *
 * Once we know what tag to insert, we need a second check in the case it was
 * a closing tag. This is because any other closing tag that comes after would
 * be left dangling alone, so we need to remove it to keep the text consistent.
 * @until }
 * @until }
 * Finally, we clear our fake selections and return the cursor back to the
 * position it had at first, since there is where we want to insert our format.
 * @until cursor_pos_set
 *
 * And finish by calling our convenience function from before, to insert the
 * text at the current cursor and give focus back to the entry.
 * @until }
 *
 * A checkbox on the top of our program tells us if the text we are editing
 * will autosave or not. In it's @c "changed" callback we get the value from
 * the checkbox and call the elm_entry_autosave_set() function with it. If
 * autosave is set, we also call elm_entry_file_save(). This is so the internal
 * timer used to periodically store to disk our changes is started.
 * @skip static void
 * @until }
 *
 * Two more functions to show some cursor playing. Whenever we double click
 * anywhere on our entry, we'll find what word is the cursor placed at and
 * select it. Likewise, for triple clicking, we select the entire line.
 * @skip static void
 * @until _edit_tplclick_cb
 * @until }
 *
 * And finally, the main window of the program contains the entry where we
 * do all the edition and some helping widgets to change format, add icons
 * or change the autosave flag.
 * @skip elm_exit
 * @skip int
 * @until _image_insert_cb
 *
 * And the main entry of the program. Set to scroll, by default we disable
 * autosave and we'll begin with a file set to it because no file selector
 * is being used here. The file is loaded with #ELM_TEXT_FORMAT_MARKUP_UTF8
 * so that any format contained in it is interpreted, otherwise the entry
 * would load it as just text, escaping any tags found and no format or icons
 * would be shown. Then we connect to the double and triple click signals
 * and set focus on the entry so we can start typing right away.
 * @until ELM_MAIN
 *
 * @example entry_example.c
 */

/**
 * @page genlist_example_01 Genlist - basic usage
 *
 * This example creates a simple genlist with a small number of items and
 * a callback that is called whenever an item is selected. All the properties of
 * this genlist are the default ones. The full code for this example can be seen
 * at @ref genlist_example_01_c.
 *
 * For the simplest list that you plan to create, it's necessary to define some
 * of the basic functions that are used for creating each list item, and
 * associating them with the "item class" for that list. The item class is just
 * an struct that contains pointers to the specific list item functions that are
 * common to all the items of the list.
 *
 * Let's show it by example. Our item class is declared globally and static as
 * it will be the only item class that we need (we are just creating one list):
 *
 * @dontinclude genlist_example_01.c
 * @skip static Elm_Genlist
 * @until static Elm_Genlist
 *
 * This item class will be used for every item that we create. The only
 * functions that we are going to set are @c label_get and @c icon_get. As the
 * name suggests, they are used by the genlist to generate the label for the
 * respective item, and to generate icon(s) to it too. Both the label and icon
 * get functions can be called more than once for each item, with different @c
 * part parameters, which represent where in the theme of the item that label or
 * icon is going to be set.
 *
 * The default theme for the genlist contains only one area for label, and two
 * areas for icon ("elm.swallow.icon" and "elm.swallow.end"). Since we just want
 * to set the first icon (that will be at the left side of the label), we
 * compare the part name given with "elm.swallow.icon". Notice that the
 * @c label_get function must return a strduped string, that will be freed later
 * automatically by the list. Here's the code for @c label_get and @c icon_get:
 *
 * @until static void
 *
 * We will also provide a function that will be called whenever an item is
 * selected in the genlist. However, this function is not part of the item
 * class, it will be passed for each item being added to the genlist explicitly.
 * Notice the similarity of the function signature with those used by @c
 * evas_object_smart_callback_add:
 *
 * @until }
 *
 * Now let's show the code used for really creating the list. Skipping
 * boilerplate code used for creating a window and background, the first piece
 * of code specific to our genlist example is setting the pointer functions of
 * the item class to our above defined functions:
 *
 * @skip _itc
 * @until func.del
 *
 * Notice that we also choose to use the "default" style for our genlist items.
 * Another interesting point is that @c state_get and @c del are set to @c NULL,
 * since we don't need these functions now. @c del doesn't need to be used
 * because we don't add any data that must be freed to our items, and @c
 * state_get is also not used since all of our items are the same and don't need
 * to have different states to be used for each item. Finally we create our
 * list:
 *
 * @until genlist_add
 *
 * Now we append several items to the list, and for all of them we need to give
 * the list pointer, a pointer to the item class, the data that will be used
 * with that item, a pointer to the parent of this item if it is in a group type
 * list (this is not the case so we pass @c NULL), possible flags for this item,
 * the callback for when the item is selected, and the data pointer that will be
 * given to the selected callback.
 *
 * @until }
 *
 * The rest of the code is also common to all the other examples, so it will be
 * omitted here (look at the full source code link above if you need it).
 *
 * You can try to play with this example, and see the selected callback being
 * called whenever an item is clicked. It also already has some features enabled
 * by default, like vertical bounce animation when reaching the end of the list,
 * automatically visible/invisible scrollbar, etc. Look at the @ref
 * genlist_example_02 to see an example of setting these properties to the list.
 *
 * The current example will look like this when running:
 *
 * @image html screenshots/genlist_example_01.png
 * @image latex screenshots/genlist_example_01.eps width=\textwidth
 */

/**
 * @page genlist_example_02 Genlist - list setup functions
 *
 * This example is very similar to the @ref genlist_example_01, but it fetch
 * most of the properties of the genlist and displays them on startup (thus
 * getting the default value for them) and then set them to some other values,
 * to show how to use that API. The full source code is at @ref
 * genlist_example_02_c.
 *
 * Considering that the base code for instantiating a genlist was already
 * described in the previous example, we are going to focus on the new code.
 *
 * Just a small difference for the @c _item_label_get function, we are going to
 * store the time that this function was called. This is the "realized" time,
 * the time when the visual representation of this item was created. This is the
 * code for the @c label_get function:
 *
 * @dontinclude genlist_example_02.c
 * @skip static char
 * @until return strdup
 *
 * Now let's go to the list creation and setup. First, just after creating the
 * list, we get most of the default properties from it, and print them on the
 * console:
 *
 * @skip genlist_add
 * @until printf("\n")
 *
 * We are going to change some of the properties of our list.
 *
 * There's no need to call the selected callback at every click, just when the
 * selected item changes, thus we call elm_genlist_select_mode_set() with
 * ELM_OBJECT_SELECT_MODE_ALWAYS.
 *
 * For this list we don't want bounce animations at all, so we set both the
 * horizontal bounce and the vertical bounce to false with
 * elm_genlist_bounce_set().
 *
 * We also want our list to compress items if they are wider than the list
 * width (thus we call elm_genlist_mode_set(obj, ELM_LIST_COMPRESS).
 *
 * The items have different width, so they are not homogeneous:
 * elm_genlist_homogeneous_set() is set to false.
 *
 * Since the compress mode is active, the call to
 * elm_genlist_mode_set() doesn't make difference, but the current
 * option would make the list to have at least the width of the largest item.
 *
 * This list will support multiple selection, so we call
 * elm_genlist_multi_select_set() on it.
 *
 * The option elm_genlist_mode_set() would allow text block to
 * wrap lines if the Edje part is configured with "text.min: 0 1", for example.
 * But since we are compressing the elements to the width of the list, this
 * option wouldn't take any effect.
 *
 * We want the vertical scrollbar to be always displayed, and the orizontal one
 * to never be displayed, and set this with elm_genlist_scroller_policy_set().
 *
 * The timeout to consider a longpress is set to half of a second with
 * elm_genlist_longpress_timeout_set().
 *
 * We also change the block count to a smaller value, but that should have not
 * impact on performance since the number of visible items is too small. We just
 * increase the granularity of the block count (setting it to have at most 4
 * items).
 *
 * @until block_count_set
 *
 * Now let's add elements to the list:
 *
 * @until item_append
 * @until }
 *
 * It's exactly the same as the previous example. The difference is on the
 * behavior of the list, if you try to scroll, select items and so.
 *
 * In this example we also need two buttons. One of them, when clicked, will
 * display several status info about the current selection, the "realized"
 * items, the item in the middle of the screen, and the current mode and active
 * item of that mode for the genlist.
 *
 * The other button will ask the genlist to "realize" again the items already
 * "realized", so their respective label_get and icon_get functions will be
 * called again.
 *
 * These are the callbacks for both of these buttons:
 *
 * @dontinclude genlist_example_02.c
 * @skip item_sel_cb
 * @skip static
 * @until }
 * @until }
 *
 * Try to scroll, select some items and click on the "Show status" button.
 * You'll notice that not all items of the list are "realized", thus consuming
 * just a small amount of memory. The selected items are listed in the order
 * that they were selected, and the current selected item printed using
 * elm_genlist_selected_item_get() is the first selected item of the multiple
 * selection.
 *
 * Now resize the window so that you can see the "realized time" of some items.
 * This is the time of when the label_get function was called. If you click on
 * the "Realize" button, all the already realized items will be rebuilt, so the
 * time will be updated for all of them.
 *
 * The current example will look like this when running:
 *
 * @image html screenshots/genlist_example_02.png
 * @image latex screenshots/genlist_example_02.eps width=\textwidth
 */

/**
 * @page genlist_example_03 Genlist - different width options
 *
 * This example doesn't present any other feature that is not already present in
 * the other examples, but visually shows the difference between using the
 * default list options (first list of the example), setting the horizontal mode
 * to #ELM_LIST_LIMIT (second list), enabling compress mode (third list) and
 * using height_for_width option (fourth list).
 *
 * The full code for this example is listed below:
 *
 * @include genlist_example_03.c
 *
 * And the screenshot of the running example:
 *
 * @image html screenshots/genlist_example_03.png
 * @image latex screenshots/genlist_example_03.eps width=\textwidth
 *
 * @example genlist_example_03.c
 */

/**
 * @page genlist_example_04 Genlist - items manipulation
 *
 * This example is also similar ot the @ref genlist_example_01, but it
 * demonstrates most of the item manipulation functions. See the full source
 * code at @ref genlist_example_04_c.
 *
 * In this example, we also will use the concept of creating groups of items in
 * the genlist. Each group of items is composed by a parent item (which will be
 * the index of the group) and several children of this item. Thus, for the
 * children, we declare a normal item class. But we also are going to declare a
 * different item class for the group index (which in practice is another type
 * of item in the genlist):
 *
 * @dontinclude genlist_example_04.c
 * @skip _item_sel_cb
 * @skip static
 * @until }
 * @until }
 *
 * We will add buttons to the window, where each button provides one
 * functionality of the genlist item API. Each button will have a callback
 * attached, that will really execute this functionality. An example of these
 * callbacks is the next one, for the elm_genlist_item_insert_after() function:
 *
 * @skip insert_before_cb
 * @skip static
 * @until }
 *
 * If you want ot see the other button functions, look at the full source code
 * link above.
 *
 * Each button will be created with a function that already creates the button,
 * add it to an elementary box, and attach the specified callback. This is the
 * function that does it:
 *
 * @skip genlist_item_update
 * @skip static
 * @until }
 *
 * In our @c elm_main function, besides the code for setting up the window, box
 * and background, we also initialize our two item classes:
 *
 * @skip _itc.item_style
 * @until _itc_group.func.del
 *
 * This example uses a different style for the items, the @a double_label, which
 * provides a text field for the item text, and another text field for a subtext.
 *
 * For the group index we use the @a group_index style, which provides a
 * different appearance, helping to identify the end of a group and beginning of
 * another one.
 *
 * Now, after the code for creating the list, setting up the box and other
 * stuff, let's add the buttons with their respective callbacks:
 *
 * @skip _button_add
 * @until bt_top_show
 *
 * The main code for adding items to the list is a bit more complex than the one
 * from the previous examples. We check if each item is multiple of 7, and if
 * so, they are group indexes (thus each group has 6 elements by default, in
 * this example):
 *
 * @skip for
 * @until }
 * @until }
 *
 * Then we also check for specific items, and add callbacks to them on the
 * respective buttons, so we can show, bring in, etc.:
 *
 * @until }
 * @until }
 *
 * Once you understand the code from the @ref genlist_example_01, it should be
 * easy to understand this one too. Look at the full code, and also try to play
 * a bit with the buttons, adding items, bringing them to the viewport, and so.
 *
 * The example will look like this when running:
 *
 * @image html screenshots/genlist_example_04.png
 * @image latex screenshots/genlist_example_04.eps width=\textwidth
 */

/**
 * @page genlist_example_05 Genlist - working with subitems
 *
 * This is probably the most complex example of elementary @ref Genlist. We
 * create a tree of items, using the subitems properties of the items, and keep
 * it in memory to be able to expand/hide subitems of an item. The full source
 * code can be found at @ref genlist_example_05_c
 *
 * The main point is the way that Genlist manages subitems. Clicking on an
 * item's button to expand it won't really show its children. It will only
 * generate the "expand,request" signal, and the expansion must be done
 * manually.
 *
 * In this example we want to be able to add items as subitems of another item.
 * If an item has any child, it must be displayed using a parent class,
 * otherwise it will use the normal item class.
 *
 * It will be possible to delete items too. Once a tree is constructed (with
 * subitems of subitems), and the user clicks on the first parent (root of the
 * tree), the entire subtree must be hidden. However, just calling
 * elm_genlist_item_expanded_set(item, EINA_FALSE) won't hide them. The only
 * thing that happens is that the parent item will change its appearance to
 * represent that it's contracted. And the signal "contracted" will be emitted
 * from the genlist. Thus, we must call elm_genlist_item_subitems_clear() to
 * delete all its subitems, but still keep a way to recreate them when expanding
 * the parent again. That's why we are going to keep a node struct for each
 * item, that will be the data of the item, with the following information:
 *
 * @dontinclude genlist_example_05.c
 * @skip typedef
 * @until }
 *
 * This @c Node_Data contains the value for the item, a number indicating its
 * level under the tree, a list of children (to be able to expand it later) and
 * a boolean indicating if it's a favorite item or not.
 *
 * We use 3 different item classes in this example:
 *
 * One for items that don't have children:
 *
 * @skip nitems
 * @skip static
 * @until }
 * @until }
 *
 * One for items that have children:
 *
 * @skip item_sel
 * @skip static
 * @until }
 * @until }
 *
 * And one for items that were favorited:
 *
 * @skip static
 * @until }
 * @until }
 *
 * The favorite item class is there just to demonstrate the
 * elm_genlist_item_item_class_update() function in action. It would be much
 * simpler to implement the favorite behavior by just changing the icon inside
 * the icon_get functions when the @c favorite boolean is activated.
 *
 * Now we are going to declare the callbacks for the buttons that add, delete
 * and change items.
 *
 * First, a button for appending items to the list:
 *
 * @until item_append
 * @until }
 *
 * If an item is selected, a new item will be appended to the same level of that
 * item, but using the selected item's parent as its parent too. If no item is
 * selected, the new item will be appended to the root of the tree.
 *
 * Then the callback for marking an item as favorite:
 *
 * @until elm_genlist_item_update
 * @until }
 *
 * This callback is very simple, it just changes the item class of the selected
 * item for the "favorite" one, or go back to the "item" or "parent" class
 * depending on that item having children or not.
 *
 * Now, the most complex operation (adding a child to an item):
 *
 * @until elm_genlist_item_update
 * @until }
 *
 * This function gets the data of the selected item, create a new data (for the
 * item being added), and appends it to the children list of the selected item.
 *
 * Then we must check if the selected item (let's call it @c item1 now) to which
 * the new item (called @c item2 from now on) was already a parent item too
 * (using the parent item class) or just a normal item (using the default item
 * class). In the first case, we just have to append the item to the end of the
 * @c item1 children list.
 *
 * However, if the @c item1 didn't have any child previously, we have to change
 * it to a parent item now. It would be easy to just change its item class to
 * the parent type, but there's no way to change the item flags and make it be
 * of the type #ELM_GENLIST_ITEM_TREE. Thus, we have to delete it and create
 * a new item, and add this new item to the same position that the deleted one
 * was. That's the reason of the checks inside the bigger @c if.
 *
 * After adding the item to the newly converted parent, we set it to not
 * expanded (since we don't want to show the added item immediately) and select
 * it again, since the original item was deleted and no item is selected at the
 * moment.
 *
 * Finally, let's show the callback for deleting items:
 *
 * @until elm_genlist_item_update
 * @until }
 *
 * Since we have an iternal list representing each element of our tree, once we
 * delete an item we have to go deleting each child of that item, in our
 * internal list. That's why we have the function @c _clear_list, which
 * recursively goes freeing all the item data.
 *
 * This is necessary because only when we really want to delete the item is when
 * we need to delete the item data. When we are just contracting the item, we
 * need to hide the children by deleting them, but keeping the item data.
 *
 * Now there are two callbacks that will be called whenever the user clicks on
 * the expand/contract icon of the item. They will just request to items to be
 * contracted or expanded:
 *
 * @until elm_genlist_item_expanded_set(
 * @until elm_genlist_item_expanded_set(
 * @until }
 *
 * When the elm_genlist_item_expanded_set() function is called with @c
 * EINA_TRUE, the @c _expanded_cb will be called. And when this happens, the
 * subtree of that item must be recreated again. This is done using the internal
 * list stored as item data for each item. The function code follows:
 *
 * @until }
 *
 * Each appended item is set to contracted, so we don't have to deal with
 * checking if the item was contracted or expanded before its parent being
 * contracted. It could be easily implemented, though, by adding a flag expanded
 * inside the item data.
 *
 * Now, the @c _contracted_cb, which is much simpler:
 *
 * @until }
 *
 * We just have to call elm_genlist_item_subitems_clear(), that will take care
 * of deleting every item, and keep the item data still stored (since we don't
 * have any del function set on any of our item classes).
 *
 * Finally, the code inside @c elm_main is very similar to the other examples:
 *
 * @skip elm_main
 * @until ELM_MAIN
 *
 * The example will look like this when running:
 *
 * @image html screenshots/genlist_example_05.png
 * @image latex screenshots/genlist_example_05.eps width=\textwidth
 */

/**
 * @page thumb_example_01 Thumb - generating thumbnails.
 *
 * This example shows how to create a simple thumbnail object with Elementary.
 * The full source code can be found at @ref thumb_example_01_c
 *
 * Everything is very simple. First we need to tell elementary that we need
 * Ethumb to generate the thumbnails:
 *
 * @dontinclude thumb_example_01.c
 * @skipline elm_need_ethumb
 *
 * Then, after creating the window and background, we setup our client to
 * generate images of 160x160:
 *
 * @skip client_get
 * @until size_set
 *
 * After that, we can start creating thumbnail objects. They are very similar to
 * image or icon objects:
 *
 * @until thumb_reload
 *
 * As you can see, the main different function here is elm_thumb_reload(), which
 * will check if the options of the Ethumb client have changed. If so, it will
 * re-generate the thumbnail, and show the new one.
 *
 * Notice in this example that the thumbnail object is displayed on the size of
 * the window (320x320 pixels), but the thumbnail generated and stored has size
 * 160x160 pixels. That's why the picture seems upscaled.
 *
 * Ideally, you will be generating thumbnails with the size that you will be
 * using them.
 *
 * The example will look like this when running:
 *
 * @image html screenshots/thumb_example_01.png
 * @image latex screenshots/thumb_example_01.eps width=\textwidth
 */

/**
 * @page progressbar_example Progress bar widget example
 *
 * This application is a thorough example of the progress bar widget,
 * consisting of a window with various progress bars, each with a given
 * look/style one can give to those widgets. With two auxiliary
 * buttons, one can start or stop a timer which will fill in the bars
 * in synchrony, simulating an underlying task being completed.
 *
 * We create @b seven progress bars, being three of them horizontal,
 * three vertical and a final one under the "wheel" alternate style.
 *
 * For the first one, we add a progress bar on total pristine state,
 * with no other call than the elm_progressbar_add() one:
 * @dontinclude progressbar_example.c
 * @skip pb with no label
 * @until pb1
 * See, than, that the defaults of a progress bar are:
 * - no primary label shown,
 * - unit label set to @c "%.0f %%",
 * - no icon set
 *
 * The second progress bar is given a primary label, <c>"Infinite
 * bounce"</c>, and, besides, it's set to @b pulse. See how, after one
 * starts the progress timer, with the "Start" button, it animates
 * differently than the previous one. It won't account for the
 * progress, itself, and just dumbly animate a small bar within its
 * bar region.
 * @dontinclude progressbar_example.c
 * @skip pb with label
 * @until pb2
 *
 * Next, comes a progress bar with an @b icon, a primary label and a
 * unit label @b function set. It's also made to grow its bar in an
 * @b inverted manner, so check that out during the timer's progression:
 * @dontinclude progressbar_example.c
 * @skip ic1 =
 * @until pb3
 * Another important thing in this one is the call to
 * elm_progressbar_span_size_set() -- this is how we forcefully set a
 * minimum horizontal size to our whole window! We're not resizing it
 * manually, as you can see in the @ref progressbar_example_c
 * "complete code".
 *
 * The format callback is a simple function that gets passed the progress value
 * and returns a string. A free function should be provided as well, if the
 * format callback allocates memory.
 * @dontinclude progressbar_example.c
 * @skip Format callback
 * @until }
 * @until }
 *
 * The last horizontal progress bar has a callback that gets called when its
 * value is @b changed. This callback updates a label to provide an estimate
 * when the operation finishes.
 * @dontinclude progressbar_example.c
 * @skip pb3
 * @skip changed trigger
 * @until pb4
 *
 * The "changed" signal is emitted every time the progressbar value is updated
 * through @ref elm_progressbar_value_set(). This callback calculates and
 * displays the ETA based on the progress and time that has passed.
 * @dontinclude progressbar_example.c
 * @skip Callback for "changed" signal
 * @until }
 * @until }
 * @until }
 *
 * The next three progress bars are just variants on the ones already
 * shown, but now all being @b vertical. Another time we use one of
 * than to give the window a minimum vertical size, with
 * elm_progressbar_span_size_set().  To demonstrate this trick once
 * more, the fifth one, which is also set to pulse, has a smaller
 * hardcoded span size:
 * @dontinclude progressbar_example.c
 * @skip vertical pb, with pulse
 * @until pb6
 *
 * We end the widget demonstration by showing a progress bar with the
 * special @b "wheel" progress bar style. One does @b not need to set
 * it to pulse, with elm_progressbar_pulse_set(), explicitly, because
 * its theme does not take it in account:
 * @dontinclude progressbar_example.c
 * @skip "wheel"
 * @until pb8
 *
 * The two buttons exercising the bars, the facto, follow:
 * @dontinclude progressbar_example.c
 * @skip elm_button_add
 * @until evas_object_show(bt)
 * @until evas_object_show(bt)
 *
 * The first of the callbacks will, for the progress bars set to
 * pulse, start the pulsing animation at that time. For the others, a
 * timer callback will take care of updating the values:
 * @dontinclude progressbar_example.c
 * @skip static Eina_Bool
 * @until }
 * @until }
 * @until }
 *
 * Finally, the callback to stop the progress timer will stop the
 * pulsing on the pulsing progress bars and, for the others, to delete
 * the timer which was acting on their values:
 * @dontinclude progressbar_example.c
 * @skip end of show
 * @until }
 * @until }
 *
 * This is how the example program's window looks like:
 * @image html screenshots/progressbar_example.png
 * @image latex screenshots/progressbar_example.eps width=\textwidth
 *
 * See the full @ref progressbar_example_c "source code" for
 * this example.
 *
 */

/**
 * @page tutorial_notify Notify example
 * @dontinclude notify_example_01.c
 *
 * In this example we will have 3 notifies in 3 different positions. The first
 * will dissappear after 5 seconds or when a outside clickking occurs, the
 * second and third will not disappear and differ from each other only in
 * position.
 *
 * We start our example with the usual stuff you've seen in other examples:
 * @until show(bx)
 *
 * We now create a label to use as the content of our first notify:
 * @until show
 *
 * Having the label we move to creating our notify, telling it to block events,
 * setting its timeout(to autohide it):
 * @until pack_end
 *
 * To have the notify dissappear when a click outside its area occur we have to
 * listen to its "block,clicked" signal:
 * @until smart_callback
 *
 * Our callback will look like this:
 * @skip static
 * @until }
 * @dontinclude notify_example_01.c
 *
 * Next we create another label and another notify. Note, however, that this
 * time we don't set a timeout and don't have it block events. What we do is set
 * the orient so that this notify will appear in the bottom of its parent:
 * @skip smart_callback
 * @skip content
 * @until pack_end
 *
 * For our third notify the only change is the orient which is now center:
 * @until pack_end
 *
 * Now we tell the main loop to run:
 * @until ELM_MAIN
 *
 * Our example will initially look like this:
 *
 * @image html screenshots/notify_example_01.png
 * @image latex screenshots/notify_example_01.eps width=\textwidth
 *
 * Once the first notify is hidden:
 *
 * @image html screenshots/notify_example_01_a.png
 * @image latex screenshots/notify_example_01_a.eps width=\textwidth
 *
 * @example notify_example_01.c
 */

/**
 * @page popup_example_01_c popup_example_01.c
 * @include popup_example_01.c
 *
 * This example will initially look like this:
 *
 * @image html screenshots/popup_example_01.png
 * @image latex screenshots/popup_example_01.eps width=\textwidth
 *
 * Once the popup is hidden after timeout:
 *
 * @image html screenshots/popup_example_01_a.png
 * @image latex screenshots/popup_example_01_a.eps width=\textwidth
 *
 * @example popup_example_01.c
 */

 /** @page popup_example_02_c popup_example_02.c
 * @include popup_example_02.c
 *
 * This example will look like this:
 *
 * @image html screenshots/popup_example_02.png
 * @image latex screenshots/popup_example_02.eps width=\textwidth
 *
 * @example popup_example_02.c
 */

/**
 * @page popup_example_03_c popup_example_03.c
 * @include popup_example_03.c
 *
 * This example will look like this:
 *
 * @image html screenshots/popup_example_03.png
 * @image latex screenshots/popup_example_03.eps width=\textwidth
 *
 * @example popup_example_03.c
 */

/**
 * @page tutorial_frame Frame example
 * @dontinclude frame_example_01.c
 *
 * In this example we are going to create 4 Frames with different styles and
 * add a rectangle of different color in each.
 *
 * We start we the usual setup code:
 * @until show(bg)
 *
 * And then create one rectangle:
 * @until show
 *
 * To add it in our first frame, which since it doesn't have it's style
 * specifically set uses the default style:
 * @until show
 *
 * And then create another rectangle:
 * @until show
 *
 * To add it in our second frame, which uses the "pad_small" style, note that
 * even tough we are setting a text for this frame it won't be show, only the
 * default style shows the Frame's title:
 * @until show
 * @note The "pad_small", "pad_medium", "pad_large" and "pad_huge" styles are
 * very similar, their only difference is the size of the empty area around
 * the content of the frame.
 *
 * And then create yet another rectangle:
 * @until show
 *
 * To add it in our third frame, which uses the "outdent_top" style, note
 * that even tough we are setting a text for this frame it won't be show,
 * only the default style shows the Frame's title:
 * @until show
 *
 * And then create one last rectangle:
 * @until show
 *
 * To add it in our fourth and final frame, which uses the "outdent_bottom"
 * style, note that even tough we are setting a text for this frame it won't
 * be show, only the default style shows the Frame's title:
 * @until show
 *
 * And now we are left with just some more setup code:
 * @until ELM_MAIN()
 *
 * Our example will look like this:
 *
 * @image html screenshots/frame_example_01.png
 * @image latex screenshots/frame_example_01.eps width=\textwidth
 *
 * @example frame_example_01.c
 */

/**
 * @page tutorial_check Check example
 * @dontinclude check_example_01.c
 *
 * This example will show 2 checkboxes, one with just a label and the second
 * one with both a label and an icon. This example also illustrates how to
 * have the checkbox change the value of a variable and how to react to those
 * changes.
 *
 * We will start with the usual setup code:
 * @skip EAPI_MAIN
 * @until elm_win_autodel_set
 *
 * And now we create our first checkbox, set its label, tell it to change
 * the value of @p value when the checkbox stats is changed and ask to be
 * notified of state changes:
 * @until show
 *
 * For our second checkbox we are going to set an icon so we need to create
 * and icon:
 * @until show
 * @note For simplicity we are using a rectangle as icon, but any evas object
 * can be used.
 *
 * And for our second checkbox we set the label, icon and state to true:
 * @until show
 *
 * We now do some more setup:
 * @until ELM_MAIN
 *
 * And finally implement the callback that will be called when the first
 * checkbox's state changes. This callback will use @p data to print a
 * message:
 * @dontinclude check_example_01.c
 * @skip static
 * @until }
 * @note This work because @p data is @p value(from the main function) and @p
 * value is changed when the checkbox is changed.
 *
 * Our example will look like this:
 *
 * @image html screenshots/check_example_01.png
 * @image latex screenshots/check_example_01.eps width=\textwidth
 *
 * @example check_example_01.c
 */

/**
 * @page tutorial_colorselector Color selector example
 * @dontinclude colorselector_example_01.c
 *
 * This example shows how to change the color of a rectangle using a color
 * selector. We aren't going to explain a lot of the code since it's the
 * usual setup code:
 * @until show(rect)
 *
 * Now that we have a window with background and a rectangle we can create
 * our color_selector
 * @until elm_colorselector_add
 *
 * Now colors can be loaded to color selector's palette by setting the palette name
 * @until show(cs)
 *
 * Next we ask to be notified whenever the color changes on selector:
 * @until changed
 *
 * Next we ask to be notified whenever the color item is selected and longpressed:
 * @until color,item,longpressed
 *
 * We add some more code to the usual setup code:
 * @until ELM_MAIN()
 *
 * now get to the "changed" callback that sets the color of the rectangle:
 * @until }
 *
 * And now get to the "color,item,selected" callback that sets the color of the rectangle:
 * @until }
 *
 * And now get to the "color,item,longpressed" callback that gets and displays
 * the color of the rectangle:
 * @until }
 *
 * This example will look like this:
 *
 * @image html screenshots/colorselector_example_01.png
 * @image latex screenshots/colorselector_example_01.eps width=\textwidth
 *
 * @example colorselector_example_01.c
 */

/**
 * @page slideshow_example Slideshow widget example
 *
 * This application is aimed to exemplify the slideshow widget. It
 * consists of a window with a slideshow widget set as "resize
 * object", along with a control bar, in the form of a notify. Those
 * controls will exercise most of the slideshow's API functions.
 *
 * We create the slideshow, itself, first, making it @b loop on its
 * image itens, when in slideshow mode:
 * @dontinclude slideshow_example.c
 * @skip slideshow = elm_slideshow_add
 * @until evas_object_show
 *
 * Next, we define the <b>item class</b> for our slideshow
 * items. Slideshow images are going to be Elementary @ref Photo "photo"
 * widgets, here, as pointed by our @c get class
 * function. We'll let the Elementary infrastructure to delete those
 * objects for us, and, as there's no additional data attached to our
 * slideshow items, the @c del class function can be left undefined:
 * @dontinclude slideshow_example.c
 * @skip itc
 * @until ;
 * @dontinclude slideshow_example.c
 * @skip itc.func
 * @until = NULL
 * @dontinclude slideshow_example.c
 * @skip get our images to make slideshow items
 * @until }
 *
 * We now get to populate the slideshow widget with items. Our images
 * are going to be some randomly chosen from the Elementary package,
 * nine of them. For the first eight, we insert them ordered in the
 * widget, by using elm_slideshow_item_sorted_insert(). The comparing
 * function will use the image names to sort items. The last item is
 * inserted at the end of the slideshow's items list, with
 * elm_slideshow_item_add(). We check out how that list ends with
 * elm_slideshow_items_get(), than:
 * @dontinclude slideshow_example.c
 * @skip static const char *img
 * @until _2
 * @dontinclude slideshow_example.c
 * @skip first =
 * @until data_get
 *
 * Note that we save the pointers to the first and last items in the
 * slideshow, for future use.
 *
 * What follows is the code creating a notify, to be shown over the
 * slideshow's viewport, with knobs to act on it. We're not showing
 * that boilerplate code, but only the callbacks attached to the
 * interesting smart events of those knobs. The first four are
 * buttons, which will:
 * - Select the @b next item in the slideshow
 * - Select the @b previous item in the slideshow
 * - Select the @b first item in the slideshow
 * - Select the @b last item in the slideshow
 *
 * Check out the code for those four actions, being the two last @c
 * data pointers the same @c first and @c last pointers we save
 * before, respectively:
 * @dontinclude slideshow_example.c
 * @skip jump to next
 * @until }
 * @until }
 * @until }
 * @until }
 *
 * What follow are two hoversels, meant for one to change the
 * slideshow's @b transition and @b layout styles, respectively. We
 * fetch all the available transition and layout names to populate
 * those widgets and, when one selects any of them, we apply the
 * corresponding setters on the slideshow:
 * @dontinclude slideshow_example.c
 * @skip hv = elm_hoversel_add
 * @until show(hv)
 * @until show(hv)
 * @dontinclude slideshow_example.c
 * @skip transition changed
 * @until }
 * @until }
 *
 * For one to change the transition @b time on the slideshow widget,
 * we use a spinner widget. We set it to the initial value of 3
 * (seconds), which will be probed by the next knob -- a button
 * starting the slideshow, de facto. Note that changing the transition
 * time while a slideshow is already happening will adjust its
 * transition time:
 * @dontinclude slideshow_example.c
 * @skip spin = elm_spinner_add
 * @until evas_object_show
 * @dontinclude slideshow_example.c
 * @skip slideshow transition time has
 * @until }
 *
 * Finally, we have two buttons which will, respectively, start and
 * stop the slideshow on our widget. Here are their "clicked"
 * callbacks:
 * @dontinclude slideshow_example.c
 * @skip start the show
 * @until }
 * @until }
 *
 * This is how the example program's window looks like:
 * @image html screenshots/slideshow_example.png
 * @image latex screenshots/slideshow_example.eps width=\textwidth
 *
 * See the full @ref slideshow_example_c "source code" for
 * this example.
 *
 */

/**
 * @page tutorial_photocam Photocam example
 * @dontinclude photocam_example_01.c
 *
 * In this example we will have a photocam and a couple of buttons and slider to
 * control the photocam. To avoid cluttering we'll only show the parts of the
 * example that relate to the photocam, the full source code can be seen @ref
 * photocam_example_01.c "here".
 *
 * Creating a photocam is as easy as creating any other widget:
 * @skipline elm_photocam_add
 *
 * A photocam is only useful if we have a image on it, so lets set a file for it
 * to work with:
 * @until file_set
 *
 * We now set the photocam to not bounce horizontally:
 * @until bounce_set
 *
 * And we want to know when the photocam has finished loading the image so:
 * @until smart_callback
 *
 * The reason to know when the image is loaded is so that we can bring the
 * center of the image into view:
 * @skip static
 * @until }
 *
 * As mentioned we have 2 buttons in this example, the "Fit" one will cause
 * the photocam to go in to a zoom mode that makes the image fit inside the
 * photocam. Tough this has no effect on the image we also print what region was
 * being viewed before setting the zoom mode:
 * @skip static
 * @until }
 * @note When in fit mode our slider(explained below) won't work.
 *
 * The second button("Unfit") will bring the photocam back into manual zoom
 * mode:
 * @skip static
 * @until }
 *
 * Our slider controls the level of zoom of the photocam:
 * @skip static
 * @until }
 * @note It is important to note that this only works when in manual zoom mode.
 *
 * Our example will initially look like this:
 *
 * @image html screenshots/photocam_example_01.png
 * @image latex screenshots/photocam_example_01.eps width=\textwidth
 *
 * @example photocam_example_01.c
 */

/**
 * @page inwin_example_01 Inwin - General overview
 *
 * Inwin is a very simple widget to show, so this example will be a very simple
 * one, just using all of the available API.
 *
 * The program is nothing but a window with a lonely button, as shown here.
 *
 * @image html screenshots/inwin_example.png
 * @image latex screenshots/inwin_example.eps width=\textwidth
 *
 * And pressing the button makes an inwin appear.
 *
 * @image html screenshots/inwin_example_a.png
 * @image latex screenshots/inwin_example_a.eps width=\textwidth
 *
 * And the code is just as simple. We being with some global variables to keep
 * track of our Inwin.
 * @dontinclude inwin_example.c
 * @skip static
 * @until current_style
 *
 * And two callbacks used by the buttons the above screenshot showed. In these,
 * we check if @c inwin exists and execute the proper action on it. If it's not
 * there anymore, then we were abandoned to our luck, so we disabled ourselves.
 * @until _inwin_destroy
 * @until }
 * @until }
 *
 * The lonely button from the beginning, when clicked, will call the following
 * function, which begins by checking if an inwin exists, and if it's there,
 * we bring it back to the front and exit from our function without any further
 * ado.
 * @until }
 *
 * But if no inwin is there to show, we need to create one. First we need the
 * top-most window for the program, as no inwin can be created using other
 * objects as parents. Then we create our popup, set the next style in the list
 * and show it.
 * @until current_style =
 *
 * As for the content of our inwin, it's just a box with a label and some
 * buttons inside.
 * @until _inwin_destroy
 * @until }
 *
 * Now, all the code above shows how every object must always be set as content
 * for some other object, be it by setting the full content, packing it in a
 * box or table or working as icon for some other widget. But we didn't do
 * anything like that for the inwin, this one is just created and shown and
 * everything works. Other widgets can be used this way, but they would need
 * to be placed and resized manually or nothing would be shown correctly. The
 * inwin, however, sets itself as a children of the top-level window and will
 * be resized as the parent window changes too.
 *
 * Another characteristic of Inwin is that when it's shown above everyone else,
 * it will work kind of like a modal window, blocking any other widget from
 * receiving events until the window is manually dismissed by pressing some
 * button to close it or having blocking task signalling its completion so
 * normal operations can be resumed. This is unlike the @ref Hover widget,
 * that would show its content on top of the designated target, but clicking
 * anywhere else would dismiss it automatically.
 *
 * To illustrate that last point, when we close the main window and an inwin
 * is still there, we'll take out the content from the inwin and place it in
 * a hover.
 * @until }
 * @until }
 *
 * And the rest of the program doesn't have anything else related to inwin,
 * so it won't be shown here, but you can find it in
 * @ref inwin_example.c "inwin_example.c".
 *
 * @example inwin_example.c
 */

/**
 * @page tutorial_scroller Scroller example
 * @dontinclude scroller_example_01.c
 *
 * This example is very short and will illustrate one way to use a scroller.
 * We'll omit the declaration of the @p text variable because it's a very long
 * @htmlonly<a href="http://lipsum.com/">@endhtmlonly ipsum lorem
 * @htmlonly</a>@endhtmlonly. If you really want to see the full code, it's @ref
 * scroller_example_01.c "scroller_example_01.c".
 *
 * We start our example by creating our window and background:
 * @skip EAPI
 * @until show(bg)
 *
 * Next we create a label and set it's text to @p text(very long ipsum lorem):
 * @until show(label)
 *
 * We then create our scroller, ask that it have the same size as the window and
 * set its content:
 * @until content_set
 *
 * We are now going to set a number of properties in our scroller:
 * @li We make it bounce horizontally but not vertically.
 * @li We make both scrollbars always be visible.
 * @li We have the events be propagated from the content to the scroller.
 * @li We enforce a page policy vertically(having a page be the size of the
 * viewport) and leave horizontal scrolling free.
 * @li And finally we ask the scroller to show us a region starting at 50,50 and
 * having a width and height of 200px.
 * @until region_show
 * @note Observant reader will note that the elm_scroller_region_show() didn't
 * scroll the view vertically, this is because we told the scroller to only
 * accept vertical scrolling in pages.
 *
 * And now we're done:
 * @until ELM_MAIN
 *
 * Our example will look like this:
 *
 * @image html screenshots/scroller_example_01.png
 * @image latex screenshots/scroller_example_01.eps width=\textwidth
 *
 * @example scroller_example_01.c
 */

/**
 * @page tutorial_table_01
 *
 * In this example we add four labels to a homogeneous table that has a padding
 * of 5px between cells.
 *
 * The interesting bits from this example are:
 * @li Where we set the table as homogeneous and the padding:
 * @dontinclude table_example_01.c
 * @skip padding_set
 * @until homogeneous_set
 * @li Where we add each label to the table:
 * @skipline elm_table_pack
 * @skipline elm_table_pack
 * @skipline elm_table_pack
 * @skipline elm_table_pack
 *
 * Here you can see the full source:
 * @include table_example_01.c
 *
 * Our example will look like this:
 *
 * @image html screenshots/table_example_01.png
 * @image latex screenshots/table_example_01.eps width=\textwidth
 *
 * @example table_example_01.c
 */

/**
 * @page tutorial_table_02
 *
 * For our second example we'll create a table with 4 rectangles in it. Since
 * our rectangles are of different sizes our table won't be homogeneous.
 *
 * The interesting bits from this example are:
 * @li Where we set the table as not homogeneous:
 * @dontinclude table_example_02.c
 * @skipline homogeneous_set
 * @li Where we add each rectangle to the table:
 * @skipline elm_table_pack
 * @skipline elm_table_pack
 * @skipline elm_table_pack
 * @skipline elm_table_pack
 *
 * Here you can see the full source:
 * @include table_example_02.c
 *
 * Our example will look like this:
 *
 * @image html screenshots/table_example_02.png
 * @image latex screenshots/table_example_02.eps width=\textwidth
 *
 * @example table_example_02.c
 */

/**
 * @page tutorial_menu Menu Example
 * @dontinclude menu_example_01.c
 *
 * This example shows how to create a menu with regular items, object items,
 * submenus and how to delete items from a menu. The full source for this
 * example is @ref menu_example_01.c "menu_example_01.c".
 *
 * We'll start looking at the menu creation and how to create a very simple
 * item:
 * @skip menu_add
 * @until item_add
 *
 * For our next item we are going to add an icon:
 * @until item_add
 *
 * Now we are going to add more items, but these icons are going to have a
 * parent, which will put them in a sub-menu. First just another item with an
 * icon:
 * @until item_add
 *
 * Next we are going to add a button to our menu(any elm widget can be added to
 * a menu):
 * @until item_add
 *
 * We are also going to have the button delete the first item of our
 * sub-menu when clicked:
 * @until smart_callback
 * @dontinclude menu_example_01.c
 * @skip static
 * @until }
 *
 * We now add a separator and three more regular items:
 * @until item_add
 * @until item_add
 * @until item_add
 *
 * We now add another item, however this time it won't go the sub-menu and it'll
 * be disabled:
 * @until disabled_set
 *
 * To make sure that our menu is shown whenever the window is clicked(and where
 * clicked) we use the following callback:
 * @dontinclude menu_example_01.c
 * @skip static
 * @skipline static
 * @until }
 *
 * Our example will look like this:
 *
 * @image html screenshots/menu_example_01.png
 * @image latex screenshots/menu_example_01.eps width=\textwidth
 *
 * @example menu_example_01.c
 */

/**
 * @page win_example_01 Win - General API overview
 *
 * For most users of the Elementary API, the @ref Win widget has a lot more
 * functions than what they need.
 *
 * In general, a developer will create a window, set some content on it and
 * forget about it for the rest of its program's life, letting whatever
 * Window Manager is there to handle the window. Here, however, we are going
 * to show how to generally manage a window.
 *
 * We'll have a bit more than the usual includes here, since part of the
 * example requires some low level fiddling.
 * @dontinclude win_example.c
 * @skip ifdef
 * @until Elementary.h
 *
 * The program then, consists of one window with two lists of buttons, each
 * of which operates on another two windows. One of them is a normal window,
 * the other has the @c override flag set so the Window Manager ignores it.
 *
 * Pressing each button will call the corresponding function to act on the
 * corresponding window. These are pretty self explanatory, so we'll show
 * them in one batch.
 * @skip static void
 * @until elm_win_sticky_set
 * @until }
 *
 * Next, we handle the main window closing. We have a @c "delete,request"
 * callback set to ask if really want to quit. If so, we end the main loop,
 * otherwise just delete the popup message and continue running normally.
 * @until _no_quit_cb
 * @until _no_quit_cb
 * @until }
 *
 * The non-managed window, being completely ignored by the Window Manager,
 * is likely to never receive keyboard focus, even if we click on its entry
 * to write something. So we have a button on it that will forcefully focus
 * it by using some lower level functions to act directly on the X window.
 * Then, each time one of the window is focused, we print some message on a
 * console to show this more clearly.
 * @until _win_focused_cb
 * @until }
 *
 * And to finalize, the main function creates a window to hold all the action
 * buttons and another two to show how (and what) works on each of them.
 *
 * First, the main window will be a normal window, we'll enable the focus
 * highlight regardless of how it is configured so it's easier to navigate
 * the window with the keyboard. Then we hook our focus and delete callbacks
 * and set up the rest of the window's content.
 * @until evas_object_show(box)
 *
 * The first of our sub-windows is the managed one. We'll create it as a
 * dialog, which should make the Window Manager treat it as a non-resizable
 * window. We are also setting the window to be auto-deleted when the close
 * button in the titlebar is pressed.
 * @until evas_object_show(o)
 *
 * Now, we added an icon to the window as a resize object. We also set this
 * icon to not scale, and no weight size hints have been set for it. This way,
 * even if we hadn't created the window as a dialog, it would still not be
 * resizable. The window size is defined by its content, so it would never be
 * smaller than the smallest of its resize objects, and for it to be resizable,
 * all of those objects have to allow it.
 *
 * Next, we add the buttons with the actions to perform on this window. Using
 * a macro saves us typing and makes the world a happier place.
 * @until WIN_ACTION(sticky)
 *
 * The maximize one is likely to not work, because the Window Manager will
 * probably not enforce it upon a window that states its maximum size, much
 * less a dialog. But that can be changed by editting the example to use
 * #ELM_WIN_BASIC when creating the window and adding the following line to
 * the icon set as content
 * @code
 * evas_object_size_hint_weight_set(o, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
 * @endcode
 *
 * Lastly, the second sub-window will have it's override flag set. In it we
 * have a label with some text, and entry and a button. The entry can be
 * clicked normally to set focus on it, but whether it actually gets keyboard
 * input will also depend on the window getting focus, and since the window
 * is an override one, it will probably not gain it by normal means. The
 * button is there to force the focus at the X level to go to our window.
 * And to finish, another list of buttons with actions to perform on this
 * last window. Remember that most of them are requests or hints for the
 * Window Manager, so they are likely to do nothing on this window.
 * Similarly, there won't be any way to move it or resize it, because we
 * haven't implemented that kind of control on this example and that's
 * something controlled by Window Managers on windows they are tracking, which
 * is not the case with this one.
 * @until ELM_MAIN
 *
 * The full code listing of this example can be found at
 * @ref win_example.c "win_example.c".
 *
 * @example win_example.c
 */

/**
 * @page web_example_02 Web - Simple example
 *
 * WebKit-EFL is independent of any particular toolkit, such as Elementary,
 * so using it on applications requires that the programmer writes a lot of
 * boiler plate code to manage to manage the web object.
 *
 * For a full featured browser this may make sense, as the programmer will
 * want to have full control of every aspect of the web object, since it's the
 * main component of the application. But other programs with simpler
 * requirements, having to write so much code is undesired.
 *
 * This is where elm_web comes in. Its purpose is to provide a simple way
 * for developers to embed a simple web object in their programs, simplifying
 * the common use cases.
 *
 * This is not to say that a browser can't be made out of it, as this example
 * shows.
 *
 * We'll be making a simple browser, consisting of one window with an URL bar,
 * a toolbar to be used for the tabs and a pager to show one page at a time.
 *
 * When all tabs are closed, we'll be showing a default view with some custom
 * content, for which we need to get the internal @c ewk_view object and use
 * some WebKit functions on it, thus we need to include the necessary headers
 * first.
 *
 * @dontinclude web_example_02.c
 * @skip include
 * @until EWebKit
 *
 * A struct to keep track of the different widgets in use and the currently
 * shown tab. There's also an @c exiting flag, used to work around the overly
 * simplistic way in which this example is written, just to avoid some
 * warnings when closing the program.
 *
 * @skip typedef
 * @skip typedef
 * @until App_Data
 *
 * Each tab has its own struct too, but there's not much to it.
 * @until };
 *
 * Whenever the currently selected tab changes, we need to update some state
 * on the application. The back and forward buttons need to be disabled
 * accordingly and the URL bar needs to show the right address.
 *
 * @skip static void
 * @until naviframe_item_simple_promote
 * @until }
 *
 * Other updates happen based on events from the web object, like title change
 * to update the name shown in the tab, and URL change which will update the
 * URL bar if the event came from the currently selected tab.
 *
 * @skip tab_current_set
 * @skip static void
 * @until }
 * @until }
 *
 * Adding a new tab is just a matter of creating a new web widget, its data
 * and pushing it into the pager. A lot of the things that we should handle
 * here, such as how to react to popups and JavaScript dialogs, are done
 * already in the @c elm_web widget, so we can rely on their default
 * implementations. For the JavaScript dialogs we are going to avoid having
 * them open in a new window by setting the @c Inwin mode.
 *
 * There is no default implementation, however, for the requests to create a
 * new window, so we have to handle them by setting a callback function that
 * will ultimately call this very same function to add a new tab.
 *
 * @skip td->tab = NULL
 * @skip Tab_Data
 * @until }
 *
 * Entering an address in the URL bar will check if a tab exists, and if not,
 * create one and set the URL for it. The address needs to conform to the URI
 * format, so we check that it does and add the protocol if it's missing.
 *
 * @skip static char
 * @until eina_stringshare_del
 * @until }
 *
 * The navigation buttons are simple enough. As for the refresh, it normally
 * reloads the page using anything that may exist in the caches if applicable,
 * but we can press it while holding the @c Shift key to avoid the cache.
 *
 * @skip static void
 * @until web_forward
 * @until }
 *
 * The callback set for the new window request creates a new tab and returns
 * the web widget associated with it. This is important, this function must
 * return a valid web widget returned by elm_web_add().
 *
 * @skip static Evas_Object
 * @until }
 *
 * Pressing @c Ctrl-F will bring up the search box. Nothing about the box
 * itself is worth mentioning here, but it works as you would expect from any
 * other browser. While typing on it, it will highlight all occurrences of the
 * searched word. Pressing @c Enter will go to the next instance and the two
 * buttons next to the entry will move forward and backwards through the found
 * keywords.
 *
 * @skip win_del_request
 * @skip static void
 * @until win_search_trigger
 * @until }
 *
 * Last, create the main window and put all of the things used above in it. It
 * contains a default web widget that will be shown when no tabs exist. This
 * web object is not browsable per se, so history is disabled in it, and we
 * set the same callback to create new windows, on top of setting some custom
 * content of our own on it, with some links that will open new tabs to start
 * browsing quickly.
 *
 * @skip static void
 * @until ELM_MAIN
 *
 * Some parts of the code were left out, as they are not relevant to the
 * example, but the full listing can be found at @ref web_example_02.c
 * "web_example_02.c".
 *
 * @example web_example_02.c
 */

/**
 * @page efl_thread_1 EFL Threading example 1
 *
 * You can use threads with Elementary (and EFL) but you need to be careful
 * to only use eina or eet calls inside a thread. Other libraries are not
 * totally threadsafe except for some specific ecore calls designed for
 * working from threads like the ecore_pipe_write() and ecore_thread calls.
 *
 * Below is an example of how to use EFL calls from a native thread you have
 * already created. You have to put the EFL calls inside the critical block
 * between ecore_thread_main_loop_begin() and ecore_thread_main_loop_end()
 * which ensure you gain a lock on the mainloop. Beware that this requires
 * that the thread WAIT to synchronize with the mainloop at the beginning of
 * the critical section. It is highly suggested you use as few of these
 * in your thread as possible and probably put just a single
 * ecore_thread_main_loop_begin() / ecore_thread_main_loop_end() section
 * at the end of the threads calculation or work when it is done and
 * would otherwise exit to sit idle.
 *
 * For a progression of examples that become more complex and show other
 * ways to use threading with EFL, please see:
 *
 * @ref efl_thread_2
 *
 * @ref efl_thread_3
 *
 * @ref efl_thread_4
 *
 * @ref efl_thread_5
 *
 * @ref efl_thread_6
 *
 * @include efl_thread_1.c
 */

/**
 * @page efl_thread_2 EFL Threading example 2
 *
 * You can also use ecore_main_loop_thread_safe_call_sync() to call a
 * specific function that needs to do EFL main loop operations. This call
 * will block and wait to synchronise to the mainloop just like
 * ecore_thread_main_loop_begin() / ecore_thread_main_loop_end() will,
 * but instead you simply provide it the function callback to call instead
 * of inlining your code.
 *
 * @ref efl_thread_3
 *
 * @ref efl_thread_4
 *
 * @ref efl_thread_5
 *
 * @ref efl_thread_6
 *
 * @include efl_thread_2.c
 */

/**
 * @page efl_thread_3 EFL Threading example 3
 *
 * Like with ecore_main_loop_thread_safe_call_sync() you can provide a
 * callback to call inline in the mainloop, but this time with
 * ecore_main_loop_thread_safe_call_async() the callback is queued and
 * called asynchronously, without the thread blocking. The mainloop will
 * call this function when it comes around to its synchronisation point. This
 * acts as a "fire and forget" way of having the mainloop do some work
 * for a thread that has finished processing some data and is read to hand it
 * off to the mainloop and the thread wants to march on and do some more work
 * while the main loop deals with "displaying" the results of the previous
 * calculation.
 *
 * @ref efl_thread_4
 *
 * @ref efl_thread_5
 *
 * @ref efl_thread_6
 *
 * @include efl_thread_3.c
 */

/**
 * @page efl_thread_4 EFL Threading example 4
 *
 * Now when you want to have a thread do some work, send back results to
 * the mainloop and continue running but the mainloop controls when the
 * thread should stop working, you need some extra flags. This is an example
 * of how you might use ecore_main_loop_thread_safe_call_async() and pthreads
 * to do this.
 *
 * @ref efl_thread_5
 *
 * @ref efl_thread_6
 *
 * @include efl_thread_4.c
 */

/**
 * @page efl_thread_5 EFL Threading example 5
 *
 * This is the same as @ref efl_thread_4 but now uses the ecore_thread
 * infrastructure to have a running worker thread that feeds results back
 * to the mainloop and can easily be cancelled. This saves some code in the
 * application and makes for fewer problem spots if you forget a mutex.
 *
 * @ref efl_thread_6
 *
 * @include efl_thread_5.c
 */

/**
 * @page efl_thread_6 EFL Threading example 6
 *
 * You can also use the ecore_thread infrastructure for compute tasks that
 * don't send feedback as they go - they are one-shot compute jobs and when
 * done they will trigger the end callback in the mainloop which is intended
 * to pick up the results and "display them".
 *
 * @include efl_thread_6.c
 */

/**
 * @page prefs_example_01 Prefs Example 01
 *
 * This example shows how to create a simple prefs widget with Elementary,
 * where the items values are "reset" on each timer tick. We do that
 * <b>programmatically</b>, to demonstrate that by touching a given prefs
 * widgets prefs data values, the changes reflect instantly on the UI.
 *
 * We'll create items on the .EPC file and after handle it on the .C file.
 *
 * @section prefs-epc-01 Creating items on EPC file
 * @dontinclude prefs_example_01.epc
 *
 * First we'll create prefs items on .EPC file that we'll use later on
 * the .C file. Note that the code is similar to .EDC (edje) files.
 *
 * @skip collection
 * @until subtitle: "Example 01";
 *
 * Here we define a page item. Pages are group of items grouped together,
 * on a given prefs widget.
 *
 * @skipline widget: "elm/vertical_box";
 *
 * In this part, we create a @c INT type item, that by default will
 * become a spinner widget in the UI, and default, min and max
 * parameters are optional as well as in @c FLOAT type.
 *
 * @skip items {
 * @until max: 150;
 * @skipline }
 * @skipline }
 *
 * Other @c INT type widget implementations may exist, as is exemplifyed
 * on the item that follows.
 *
 * @skip item {
 * @until min: 0;
 * @skipline }
 * @skipline }
 *
 * Now we create a LABEL type item and by default will become a read-only
 * label in UI.
 *
 * @skip item {
 * @until }
 *
 * Now we create a TEXT type item and by default will become a single-line
 * text entry in UI. Note that we use a Regular Expression to deny only
 * entries with numbers.
 *
 * @skip item {
 * @until }
 * @skipline }
 *
 * In this part we create a DATE type item, by default will become a datetime
 * in UI, and default, min and max parameters are optional.
 *
 * @skip item {
 * @until }
 *
 * Here we create a SEPARATOR type item, it has no value bound,
 * serves only to divide and organize prefs items.
 *
 * @skip item {
 * @until }
 *
 * In this part, we create a SAVE type item that will get all the values
 * bounded to items and save it on CFG file. Next time you execute the
 * application, all the values that you saved before will be loaded.
 *
 * @skip item {
 * @until }
 *
 * Here we create a RESET type item that will return all the values bounded
 * to items as default declared on .EPC file.
 *
 * @skip item {
 * @until }
 *
 * Pages and items have default implementation widgets, but, with the tag
 * 'widget', you can use different widgets for prefs items. To a list of
 * default widgets supported by each type, by default, refer to the Elementary
 * Prefs Collection reference sheet. One can also register, at run time,
 * custom item widget handlers too.
 *
 * @section prefs-c-01 Handling items on C File
 * @dontinclude prefs_example_01.c
 *
 * Now we're handling the .C file and first we'll create a prefs widget.
 *
 * @skip prefs = elm_prefs_add(win);
 * @until evas_object_show(prefs);
 *
 * Here we add some specific callbacks, for example "item,changed" that will
 * be called when any item that we created on EPC file changes.
 *
 * @skip evas_object_smart_callback_add
 * @until _item_changed_cb, win);
 *
 * Here we set the prefs to save its values back (on the user data file)
 * automatically on every UI element changes.
 *
 * @skipline elm_prefs_autosave_set(prefs, EINA_TRUE);
 *
 * In this part we create the prefs data handle and set the .EPB file
 * (.EPC compiled). This .EPB file contains all the default values from the
 * items that we created, this file will be loaded when the program starts or
 * when clicked on a RESET type item. There is another file created when
 * the values from prefs items are saved, the .CFG file, that contains all the
 * non-standard saved values from the prefs items, this file will be loaded
 * when program starts as well.
 *
 * @dontinclude prefs_example_01.c
 * @skipline Elm_Prefs_Data *prefs_data;
 *
 * @skip prefs_data = elm_prefs_data_new
 * @until elm_prefs_data_set(prefs, prefs_data);
 *
 * Here we just create a notify widget to appear when the values are reset.
 *
 * @skip label = elm_label_add(win);
 * @until evas_object_show(notify);
 *
 * Now we add a timer to reset the items values on each 5.0 seconds and
 * show the notify.
 *
 * @skipline evas_object_data_set(notify
 * @skipline timer = ecore_timer_add(5.0,
 *
 * @dontinclude prefs_example_01.c
 * @skip _elm_prefs_data_change(void *data)
 * @until return ECORE_CALLBACK_RENEW;
 * @skipline }
 *
 * Here we finish the example. The full source code can be found on
 * @ref prefs_example_01_c and
 * @ref prefs_example_01_epc
 *
 */

/**
 * @page prefs_example_02 Prefs Example 02
 *
 * This example shows how to create a simple prefs widget with Elementary,
 * where some items properties are changed on each timer tick.
 *
 * We'll create items on the .EPC file and after handle it on the .C file.
 *
 * @section prefs-epc-02 Creating items on EPC file
 * @dontinclude prefs_example_02.epc
 *
 * First we'll create prefs items on .EPC file that we'll use later on
 * the .C file. Note that the code is similar to .EDC (edje) files.
 *
 * @skip collection
 * @until widget: "elm/vertical_frame";
 *
 * In this part, we create a @c TEXTAREA item and, by default, it will
 * become a multi-line text entry in the UI. Note that we use a
 * regular expression to accept only characters and whitespaces in it.
 *
 * @skip items {
 * @until }
 * @skipline }
 *
 * Now we create a FLOAT type item, by default will become a spinner in UI,
 * and default, min and max parameters are optional as well as in INT type.
 *
 * @skip item {
 * @until }
 * @skipline }
 *
 * Here we create a BOOL type item, by default will become a checkbox in UI.
 *
 * @skip item {
 * @until }
 * @skipline }
 *
 * Here we create two items, separator and save types, that we've already
 * covered in
 * @ref prefs_example_01
 *
 * @skip item {
 * @until label: "Save";
 * @skipline }
 *
 * In this part, we create a ACTION type item. when clicked, the
 * action item will emit a signal to .C file and call a smart callback.
 *
 * @skip item {
 * @until }
 * @skipline }
 * @skipline }
 * @skipline }
 *
 * @section prefs-c-02 Handling items on C File
 * @dontinclude prefs_example_02.c
 *
 * Now we're handling the .C file and first we'll create a prefs widget.
 *
 * @skip prefs = elm_prefs_add(win);
 * @until evas_object_show(prefs);
 *
 * In this part we add the action smart callback, that will be called when
 * the action item be clicked.
 *
 * @skipline evas_object_smart_callback_add
 *
 * Here we add a simple action item callback that sets a text to another item.
 *
 * @dontinclude prefs_example_02.c
 * @skip _action_cb(void *data
 * @until }
 *
 * Now we set the prefs to save its values back (on the user data file)
 * automatically on every UI element changes.
 *
 * @skipline elm_prefs_autosave_set(prefs, EINA_TRUE);
 *
 * In this part we create the prefs data handle and set the .EPB file
 * (.EPC compiled).
 *
 * @dontinclude prefs_example_02.c
 * @skipline Elm_Prefs_Data *prefs_data;
 *
 * @skip prefs_data = elm_prefs_data_new
 * @until elm_prefs_data_set(prefs, prefs_data);
 *
 * Here we just create a notify widget to appear when the items properties
 * are changed.
 *
 * @skip label = elm_label_add(win);
 * @until evas_object_show(notify);
 *
 * Now we add a timer to change text editable, spinners visibility and checkbox
 * enable/disable properties on each 5.0 seconds and show the notify.
 *
 * @skip evas_object_data_set(notify
 * @until _elm_prefs_items_change, notify);
 *
 * @dontinclude prefs_example_02.c
 * @skip _elm_prefs_items_change(void *data)
 * @until return ECORE_CALLBACK_RENEW;
 * @skipline }
 *
 * Here we finish the example. The full source code can be found on
 * @ref prefs_example_02_c and
 * @ref prefs_example_02_epc
 *
 */

/**
 * @page prefs_example_03 Prefs Example 03
 *
 * This example shows how to create a prefs widget with Elementary, where some
 * prefs item values are changed, some actions take place on an object
 * different than the prefs widget (an Edge object). With this new object,
 * we're also exemplifying the prefs SWALLOW item type, as the Edje object is
 * put inside the prefs widget's viewport.
 *
 * It also shows how subpages can be created using the prefs PAGE item type.
 *
 * Explain step by step the .EDC file is out of scope, the source code
 * can be found at
 * @ref prefs_example_03_edc
 *
 * @section prefs-epc-03 Creating items on EPC file
 * @dontinclude prefs_example_03.epc
 *
 * First we'll create prefs items on .EPC file that we'll use later on
 * the .C file.
 *
 * @skip collection
 * @until widget: "elm/vertical_frame";
 *
 * In the following part, we create an item of the PAGE type, that will create a
 * subpage inside the main page. The source parameter is used to set which page
 * will be used to fill the subpage, in this example, the page named
 * "configpage" will be used.
 *
 * @skip items {
 * @until type: SEPARATOR;
 * @skipline }
 *
 * Now we create a SWALLOW type item, that, as the name suggests, will
 * swallow an Evas_Object.
 *
 * @skip item {
 * @until }
 *
 * Now we create the page that will be used to fill the item "config" of the
 * main page. It has another two subpages and a SEPARATOR item arranged
 * horizontally so we could achieve the desired layout.
 *
 * @skip page
 * @until source: "buttonspage";
 * @skipline }
 * @skipline }
 * @skipline }
 *
 * Then we create the pages used by the "configpage" page, whose items
 * were covered in @ref prefs_example_01 and @ref prefs_example_02.
 *
 * @skip page
 * @until label: "Reset";
 * @skipline }
 * @skipline }
 * @skipline }
 *
 * @section prefs-c-03 Handling items on C File
 * @dontinclude prefs_example_03.c
 *
 * Now we're handling the .C file and first we'll create a layout setting the
 * edje file to after a prefs item swallows it.
 *
 * @skip layout = elm_layout_add(win);
 * @until "prefs_edje");
 *
 * Here we create the prefs widget, add smart callbacks and create the prefs
 * data handle.
 *
 * @skip prefs = elm_prefs_add(win);
 * @until elm_prefs_data_set(prefs, prefs_data);
 *
 * Now we "swallow" the layout into the SWALLOW item of the prefs widget.
 *
 * @skipline elm_prefs_item_swallow(prefs,
 *
 * Page loaded and item changed callbacks will call update functions.
 *
 * @dontinclude prefs_example_03.c
 * @skip _page_loaded_cb(void *data,
 * @until _update_animation(obj, layout);
 * @skipline }
 *
 * These update functions will be called in order to get the new value from
 * the items and pass it as signal to edje handle it and affects on animation.
 *
 * @dontinclude prefs_example_03.c
 * @skip _update(Evas_Object *prefs,
 * @until }
 *
 * In this function we'll get the checkbox (bool) value and start or stop
 * the animation on edje.
 *
 * @dontinclude prefs_example_03.c
 * @skip _update_animation(Evas_Object *prefs,
 * @until }
 *
 * In this function we'll get the slider (float item) value and send it as
 * animation time to edje.
 *
 * @skip _update_animation_time(Evas_Object *prefs,
 * @until }
 *
 * Here we finish the example. The full source code can be found on
 * @ref prefs_example_03_c,
 * @ref prefs_example_03_epc and
 * @ref prefs_example_03_edc
 *
 */

/**
 * @page bg_example_01_c bg_example_01.c
 * @include bg_example_01.c
 * @example bg_example_01.c
 */


/**
 * @page bg_example_02_c bg_example_02.c
 * @include bg_example_02.c
 * @example bg_example_02.c
 */

/**
 * @page bg_example_03_c bg_example_03.c
 * @include bg_example_03.c
 * @example bg_example_03.c
 */

/**
 * @page actionslider_example_01 Actionslider example
 * @include actionslider_example_01.c
 * @example actionslider_example_01.c
 */

/**
 * @page transit_example_01_c Transit example 1
 * @include transit_example_01.c
 * @example transit_example_01.c
 */

/**
 * @page transit_example_02_c Transit example 2
 * @include transit_example_02.c
 * @example transit_example_02.c
 */

/**
 * @page general_functions_example_c General (top-level) functions example
 * @include general_funcs_example.c
 * @example general_funcs_example.c
 */

/**
 * @page clock_example_c Clock example
 * @include clock_example.c
 * @example clock_example.c
 */

 /**
 * @page datetime_example_c Datetime example
 * @include datetime_example.c
 * @example datetime_example.c
 */

/**
 * @page dayselector_example_c Dayselector example
 * @include dayselector_example.c
 * @example dayselector_example.c
 */

/**
 * @page flipselector_example_c Flipselector example
 * @include flipselector_example.c
 * @example flipselector_example.c
 */

/**
 * @page fileselector_example_c Fileselector example
 * @include fileselector_example.c
 * @example fileselector_example.c
 */

/**
 * @page fileselector_button_example_c Fileselector button example
 * @include fileselector_button_example.c
 * @example fileselector_button_example.c
 */

/**
 * @page fileselector_entry_example_c Fileselector entry example
 * @include fileselector_entry_example.c
 * @example fileselector_entry_example.c
 */

/**
 * @page index_example_01_c Index example
 * @include index_example_01.c
 * @example index_example_01.c
 */

/**
 * @page index_example_02_c Index example
 * @include index_example_02.c
 * @example index_example_02.c
 */

/**
 * @page layout_example_01_c layout_example_01.c
 * @include layout_example_01.c
 * @example layout_example_01.c
 */

/**
 * @page layout_example_02_c layout_example_02.c
 * @include layout_example_02.c
 * @example layout_example_02.c
 */

/**
 * @page layout_example_03_c layout_example_03.c
 * @include layout_example_03.c
 * @example layout_example_03.c
 */

/**
 * @page layout_example_edc An example of layout theme file
 *
 * This theme file contains two groups. Each of them is a different theme, and
 * can be used by an Elementary Layout widget. A theme can be used more than
 * once by many different Elementary Layout widgets too.
 *
 * @include layout_example.edc
 * @example layout_example.edc
 */

/**
 * @page gengrid_example_c Gengrid example
 * @include gengrid_example.c
 * @example gengrid_example.c
 */

/**
 * @page genlist_example_01_c genlist_example_01.c
 * @include genlist_example_01.c
 * @example genlist_example_01.c
 */

/**
 * @page genlist_example_02_c genlist_example_02.c
 * @include genlist_example_02.c
 * @example genlist_example_02.c
 */

/**
 * @page genlist_example_04_c genlist_example_04.c
 * @include genlist_example_04.c
 * @example genlist_example_04.c
 */

/**
 * @page genlist_example_05_c genlist_example_05.c
 * @include genlist_example_05.c
 * @example genlist_example_05.c
 */

/**
 * @page thumb_example_01_c thumb_example_01.c
 * @include thumb_example_01.c
 * @example thumb_example_01.c
 */

/**
 * @page progressbar_example_c Progress bar example
 * @include progressbar_example.c
 * @example progressbar_example.c
 */

/**
 * @page slideshow_example_c Slideshow example
 * @include slideshow_example.c
 * @example slideshow_example.c
 */

/**
 * @page efl_thread_1_c EFL Threading example 1
 * @include efl_thread_1.c
 * @example efl_thread_1.c
 */

/**
 * @page efl_thread_2_c EFL Threading example 2
 * @include efl_thread_2.c
 * @example efl_thread_2.c
 */

/**
 * @page efl_thread_3_c EFL Threading example 3
 * @include efl_thread_3.c
 * @example efl_thread_3.c
 */

/**
 * @page efl_thread_4_c EFL Threading example 4
 * @include efl_thread_4.c
 * @example efl_thread_4.c
 */

/**
 * @page efl_thread_5_c EFL Threading example 5
 * @include efl_thread_5.c
 * @example efl_thread_5.c
 */

/**
 * @page efl_thread_6_c EFL Threading example 6
 * @include efl_thread_6.c
 * @example efl_thread_6.c
 */

/**
 * @page prefs_example_01_c prefs_example_01.c
 * @include prefs_example_01.c
 * @example prefs_example_01.c
 */

/**
 * @page prefs_example_01_epc prefs_example_01.epc
 * @include prefs_example_01.epc
 * @example prefs_example_01.epc
 */

/**
 * @page prefs_example_02_c prefs_example_02.c
 * @include prefs_example_02.c
 * @example prefs_example_02.c
 */

/**
 * @page prefs_example_02_epc prefs_example_02.epc
 * @include prefs_example_02.epc
 * @example prefs_example_02.epc
 */

/**
 * @page prefs_example_03_c prefs_example_03.c
 * @include prefs_example_03.c
 * @example prefs_example_03.c
 */

/**
 * @page prefs_example_03_epc prefs_example_03.epc
 * @include prefs_example_03.epc
 * @example prefs_example_03.epc
 */

/**
 * @page prefs_example_03_edc prefs_example_03.edc
 * @include prefs_example_03.edc
 * @example prefs_example_03.edc
 */

/**
 * @example prefs_data_example.c
 * @example glview_example_01.c
 * @example track_example_01.c
 * @example codegen_example.c
 * @example efl_thread_win32_1.c
 * @example efl_thread_win32_2.c
 * @example efl_thread_win32_3.c
 * @example efl_thread_win32_4.c
 * @example location_example_01.c
 * @example naviframe_example.c
 */
